<!DOCTYPE html>
<html lang="zh-cn" dir="ltr" class="client-nojs">
<head>
<title>XEP-0124 - Jabber/XMPP中文翻译计划</title>
<meta charset="UTF-8" />
<meta name="generator" content="MediaWiki 1.18.2" />
<link rel="shortcut icon" href="/favicon.ico" />
<link rel="search" type="application/opensearchdescription+xml" href="/opensearch_desc.php" title="Jabber/XMPP中文翻译计划 (zh-cn)" />
<link rel="EditURI" type="application/rsd+xml" href="http://wiki.jabbercn.org/api.php?action=rsd" />
<link rel="copyright" href="http://creativecommons.org/licenses/by-nc-sa/3.0/" />
<link rel="alternate" type="application/atom+xml" title="Jabber/XMPP中文翻译计划的Atom" href="/index.php?title=%E7%89%B9%E6%AE%8A:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9&amp;feed=atom" />
<link rel="stylesheet" href="/load.php?debug=false&amp;lang=zh-cn&amp;modules=mediawiki.legacy.commonPrint%2Cshared%7Cskins.monobook&amp;only=styles&amp;skin=monobook&amp;*" />
<!--[if lt IE 5.5000]><link rel="stylesheet" href="/skins/monobook/IE50Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 5.5000]><link rel="stylesheet" href="/skins/monobook/IE55Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 6]><link rel="stylesheet" href="/skins/monobook/IE60Fixes.css?303" media="screen" /><![endif]-->
<!--[if IE 7]><link rel="stylesheet" href="/skins/monobook/IE70Fixes.css?303" media="screen" /><![endif]--><meta name="ResourceLoaderDynamicStyles" content="" />
<style>a:lang(ar),a:lang(ckb),a:lang(fa),a:lang(kk-arab),a:lang(mzn),a:lang(ps),a:lang(ur){text-decoration:none}a.new,#quickbar a.new{color:#ba0000}

/* cache key: mediawiki:resourceloader:filter:minify-css:4:c88e2bcd56513749bec09a7e29cb3ffa */</style>
<script src="/load.php?debug=false&amp;lang=zh-cn&amp;modules=startup&amp;only=scripts&amp;skin=monobook&amp;*"></script>
<script>if(window.mw){
	mw.config.set({"wgCanonicalNamespace": "", "wgCanonicalSpecialPageName": false, "wgNamespaceNumber": 0, "wgPageName": "XEP-0124", "wgTitle": "XEP-0124", "wgCurRevisionId": 3126, "wgArticleId": 65, "wgIsArticle": true, "wgAction": "view", "wgUserName": null, "wgUserGroups": ["*"], "wgCategories": ["XMPP扩展", "已翻译"], "wgBreakFrames": false, "wgRestrictionEdit": [], "wgRestrictionMove": [], "wgSearchNamespaces": [0]});
}
</script><script>if(window.mw){
	mw.loader.load(["mediawiki.page.startup"]);
}
</script>
<style type="text/css">/*<![CDATA[*/
.source-xml {border: 1px dashed #2f6fab; color: black; background-color: #f9f9f9;}
.source-xml li, .source-xml pre {
	line-height: normal; border: 0px none white;
}
/**
 * GeSHi Dynamically Generated Stylesheet
 * --------------------------------------
 * Dynamically generated stylesheet for xml
 * CSS class: source-xml, CSS id: 
 * GeSHi (C) 2004 - 2007 Nigel McNie, 2007 - 2008 Benny Baumann
 * (http://qbnz.com/highlighter/ and http://geshi.org/)
 * --------------------------------------
 */
.source-xml .de1, .source-xml .de2 {font-family: monospace; font-weight: normal; font-style: normal; margin:0; padding:0; background:inherit;}
.source-xml  {font-family: monospace;}
.source-xml .imp {font-weight: bold; color: red;}
.source-xml li, .source-xml li.li1 {font-weight: normal;}
.source-xml li.li2 {font-weight: bold;}
.source-xml .co1 {color: #808080; font-style: italic;}
.source-xml .co2 {color: #404040; font-style: italic;}
.source-xml .co3 {color: #000000;}
.source-xml .co4 {color: #400000; font-weight: bold;}
.source-xml .es0 {color: #000099; font-weight: bold;}
.source-xml .br0 {color: #66cc66;}
.source-xml .sy0 {color: #66cc66;}
.source-xml .st0 {color: #ff0000;}
.source-xml .nu0 {color: #cc66cc;}
.source-xml .re0 {color: #000066;}
.source-xml .re1 {color: #000000; font-weight: bold;}
.source-xml .re2 {color: #000000; font-weight: bold;}
.source-xml .ln-xtra, .source-xml li.ln-xtra, .source-xml div.ln-xtra {background-color: #ffc;}
.source-xml span.xtra { display:block; }

/*]]>*/
</style>
<style type="text/css">/*<![CDATA[*/
@import "/index.php?title=MediaWiki:Geshi.css&usemsgcache=yes&action=raw&ctype=text/css&smaxage=18000";
/*]]>*/
</style></head>
<body class="mediawiki ltr sitedir-ltr ns-0 ns-subject page-XEP-0124 action-view skin-monobook">
<div id="globalWrapper">
<div id="column-content"><div id="content">
	<a id="top"></a>
	
	<h1 id="firstHeading" class="firstHeading">XEP-0124</h1>
	<div id="bodyContent">
		<div id="siteSub">来自Jabber/XMPP中文翻译计划</div>
		<div id="contentSub"></div>
		<div id="jump-to-nav">跳转到： <a href="#column-one">导航</a>, <a href="#searchInput">搜索</a></div>
		<!-- start content -->
<div lang="zh-cn" dir="ltr" class="mw-content-ltr"><p><br />
<b>本文的英文原文来自<a rel="nofollow" class="external text" href="http://www.xmpp.org/extensions/xep-0124.html">XEP-0124</a></b>
</p><p><b>XEP-0124: 基于同步HTTP的双向流</b>
</p>
<table>
<tr>
<th>摘要:
</th>
<td>本协议定义了一个传输协议来模拟两个实体 (例如一个客户端和一个服务器) 之间的长连双向TCP连接的语义，它有效地运用多个同步的HTTP"请求/应答"对，而不需要使用频繁的轮询或者分块响应.
</td></tr>
<tr>
<th>作者:
</th>
<td>Ian Paterson, Dave Smith, Peter Saint-Andre, Jack Moffitt
</td></tr>
<tr>
<th>版权:
</th>
<td>© 1999 - 2011 XMPP标准化基金会(XSF). 参见<a href="/XEP-0124#.E9.99.84.E5.BD.95C:.E6.B3.95.E5.BE.8B.E9.80.9A.E5.91.8A" title="XEP-0124">法律通告</a>.
</td></tr>
<tr>
<th>状态:
</th>
<td>草案
</td></tr>
<tr>
<th>类型:
</th>
<td>标准跟踪
</td></tr>
<tr>
<th>版本:
</th>
<td>1.10
</td></tr>
<tr>
<th>最后更新日期:
</th>
<td>2010-07-02
</td></tr></table>
<hr />
<p>注意: 这里定义的协议是XMPP标准化基金会的一个 <b>草案标准</b> .对本协议的执行是被鼓励的,也适于部署到生产系统,但是在它成为最终标准之前可能还会有一些变动.
</p>
<hr />
<table id="toc" class="toc"><tr><td><div id="toctitle"><h2>目录</h2></div>
<ul>
<li class="toclevel-1 tocsection-1"><a href="#.E7.AE.80.E4.BB.8B"><span class="tocnumber">1</span> <span class="toctext">简介</span></a></li>
<li class="toclevel-1 tocsection-2"><a href="#.E9.9C.80.E6.B1.82"><span class="tocnumber">2</span> <span class="toctext">需求</span></a></li>
<li class="toclevel-1 tocsection-3"><a href="#.E6.9E.B6.E6.9E.84.E5.81.87.E8.AE.BE"><span class="tocnumber">3</span> <span class="toctext">架构假设</span></a></li>
<li class="toclevel-1 tocsection-4"><a href="#BOSH.E6.8A.80.E6.9C.AF"><span class="tocnumber">4</span> <span class="toctext">BOSH技术</span></a></li>
<li class="toclevel-1 tocsection-5"><a href="#HTTP.E6.A6.82.E8.BF.B0"><span class="tocnumber">5</span> <span class="toctext">HTTP概述</span></a></li>
<li class="toclevel-1 tocsection-6"><a href="#.3Cbody.2F.3E.E5.B0.81.E8.A3.85.E5.99.A8.E5.85.83.E7.B4.A0"><span class="tocnumber">6</span> <span class="toctext">&lt;body/&gt;封装器元素</span></a></li>
<li class="toclevel-1 tocsection-7"><a href="#.E5.8F.91.E8.B5.B7BOSH.E4.BC.9A.E8.AF.9D"><span class="tocnumber">7</span> <span class="toctext">发起BOSH会话</span></a>
<ul>
<li class="toclevel-2 tocsection-8"><a href="#.E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E8.AF.B7.E6.B1.82"><span class="tocnumber">7.1</span> <span class="toctext">会话创建请求</span></a></li>
<li class="toclevel-2 tocsection-9"><a href="#.E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E5.BA.94.E7.AD.94"><span class="tocnumber">7.2</span> <span class="toctext">会话创建应答</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-10"><a href="#.E5.8F.91.E9.80.81.E5.92.8C.E6.8E.A5.E6.94.B6XML.E8.BD.BD.E8.8D.B7"><span class="tocnumber">8</span> <span class="toctext">发送和接收XML载荷</span></a></li>
<li class="toclevel-1 tocsection-11"><a href="#.E7.A1.AE.E8.AE.A4"><span class="tocnumber">9</span> <span class="toctext">确认</span></a>
<ul>
<li class="toclevel-2 tocsection-12"><a href="#.E8.AF.B7.E6.B1.82.E7.A1.AE.E8.AE.A4"><span class="tocnumber">9.1</span> <span class="toctext">请求确认</span></a></li>
<li class="toclevel-2 tocsection-13"><a href="#.E5.BA.94.E7.AD.94.E7.A1.AE.E8.AE.A4"><span class="tocnumber">9.2</span> <span class="toctext">应答确认</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-14"><a href="#.E9.97.B2.E7.BD.AE"><span class="tocnumber">10</span> <span class="toctext">闲置</span></a></li>
<li class="toclevel-1 tocsection-15"><a href="#.E8.BF.87.E5.BA.A6.E6.B4.BB.E8.B7.83"><span class="tocnumber">11</span> <span class="toctext">过度活跃</span></a></li>
<li class="toclevel-1 tocsection-16"><a href="#.E8.BD.AE.E8.AF.A2.E4.BC.9A.E8.AF.9D"><span class="tocnumber">12</span> <span class="toctext">轮询会话</span></a></li>
<li class="toclevel-1 tocsection-17"><a href="#.E7.BB.88.E6.AD.A2HTTP.E4.BC.9A.E8.AF.9D"><span class="tocnumber">13</span> <span class="toctext">终止HTTP会话</span></a></li>
<li class="toclevel-1 tocsection-18"><a href="#.E8.AF.B7.E6.B1.82IDs"><span class="tocnumber">14</span> <span class="toctext">请求IDs</span></a>
<ul>
<li class="toclevel-2 tocsection-19"><a href="#.E7.94.9F.E6.88.90"><span class="tocnumber">14.1</span> <span class="toctext">生成</span></a></li>
<li class="toclevel-2 tocsection-20"><a href="#.E9.A1.BA.E5.BA.8F.E7.9A.84.E6.B6.88.E6.81.AF.E8.BD.AC.E5.8F.91"><span class="tocnumber">14.2</span> <span class="toctext">顺序的消息转发</span></a></li>
<li class="toclevel-2 tocsection-21"><a href="#.E6.96.AD.E5.BC.80.E7.9A.84.E8.BF.9E.E6.8E.A5"><span class="tocnumber">14.3</span> <span class="toctext">断开的连接</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-22"><a href="#.E4.BF.9D.E6.8A.A4.E4.B8.8D.E5.AE.89.E5.85.A8.E7.9A.84.E4.BC.9A.E8.AF.9D"><span class="tocnumber">15</span> <span class="toctext">保护不安全的会话</span></a>
<ul>
<li class="toclevel-2 tocsection-23"><a href="#.E9.80.82.E7.94.A8.E6.80.A7"><span class="tocnumber">15.1</span> <span class="toctext">适用性</span></a></li>
<li class="toclevel-2 tocsection-24"><a href="#.E7.AE.80.E8.BF.B0"><span class="tocnumber">15.2</span> <span class="toctext">简述</span></a></li>
<li class="toclevel-2 tocsection-25"><a href="#.E7.94.9F.E6.88.90.E5.AF.86.E9.92.A5.E5.BA.8F.E5.88.97"><span class="tocnumber">15.3</span> <span class="toctext">生成密钥序列</span></a></li>
<li class="toclevel-2 tocsection-26"><a href="#.E4.BD.BF.E7.94.A8.E5.AF.86.E9.92.A5"><span class="tocnumber">15.4</span> <span class="toctext">使用密钥</span></a></li>
<li class="toclevel-2 tocsection-27"><a href="#.E5.88.87.E6.8D.A2.E5.88.B0.E5.8F.A6.E4.B8.80.E4.B8.AA.E5.AF.86.E9.92.A5.E5.BA.8F.E5.88.97"><span class="tocnumber">15.5</span> <span class="toctext">切换到另一个密钥序列</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-28"><a href="#.E5.A4.9A.E9.87.8D.E6.B5.81"><span class="tocnumber">16</span> <span class="toctext">多重流</span></a>
<ul>
<li class="toclevel-2 tocsection-29"><a href="#.E7.AE.80.E4.BB.8B_2"><span class="tocnumber">16.1</span> <span class="toctext">简介</span></a></li>
<li class="toclevel-2 tocsection-30"><a href="#.E6.9F.A5.E8.AF.A2"><span class="tocnumber">16.2</span> <span class="toctext">查询</span></a></li>
<li class="toclevel-2 tocsection-31"><a href="#.E6.B7.BB.E5.8A.A0.E6.B5.81.E5.88.B0.E4.BC.9A.E8.AF.9D"><span class="tocnumber">16.3</span> <span class="toctext">添加流到会话</span></a></li>
<li class="toclevel-2 tocsection-32"><a href="#.E4.BC.A0.E9.80.81.E8.BD.BD.E8.8D.B7"><span class="tocnumber">16.4</span> <span class="toctext">传送载荷</span></a></li>
<li class="toclevel-2 tocsection-33"><a href="#.E5.85.B3.E9.97.AD.E6.B5.81"><span class="tocnumber">16.5</span> <span class="toctext">关闭流</span></a></li>
<li class="toclevel-2 tocsection-34"><a href="#.E9.94.99.E8.AF.AF.E6.9D.A1.E4.BB.B6"><span class="tocnumber">16.6</span> <span class="toctext">错误条件</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-35"><a href="#.E9.94.99.E8.AF.AF.E5.92.8C.E7.8A.B6.E6.80.81.E4.BB.A3.E7.A0.81"><span class="tocnumber">17</span> <span class="toctext">错误和状态代码</span></a>
<ul>
<li class="toclevel-2 tocsection-36"><a href="#HTTP.E6.9D.A1.E4.BB.B6"><span class="tocnumber">17.1</span> <span class="toctext">HTTP条件</span></a></li>
<li class="toclevel-2 tocsection-37"><a href="#.E7.BB.88.E6.AD.A2.E7.BB.91.E5.AE.9A.E6.9D.A1.E4.BB.B6"><span class="tocnumber">17.2</span> <span class="toctext">终止绑定条件</span></a></li>
<li class="toclevel-2 tocsection-38"><a href="#.E5.8F.AF.E6.81.A2.E5.A4.8D.E7.9A.84.E7.BB.91.E5.AE.9A.E6.9D.A1.E4.BB.B6"><span class="tocnumber">17.3</span> <span class="toctext">可恢复的绑定条件</span></a></li>
<li class="toclevel-2 tocsection-39"><a href="#XML.E8.BD.BD.E8.8D.B7.E6.9D.A1.E4.BB.B6"><span class="tocnumber">17.4</span> <span class="toctext">XML载荷条件</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-40"><a href="#.E5.AE.9E.E7.8E.B0.E5.A4.87.E6.B3.A8"><span class="tocnumber">18</span> <span class="toctext">实现备注</span></a>
<ul>
<li class="toclevel-2 tocsection-41"><a href="#HTTP.E6.B5.81.E6.B0.B4.E7.BA.BF"><span class="tocnumber">18.1</span> <span class="toctext">HTTP流水线</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-42"><a href="#.E5.AE.89.E5.85.A8.E4.BA.8B.E9.A1.B9"><span class="tocnumber">19</span> <span class="toctext">安全事项</span></a>
<ul>
<li class="toclevel-2 tocsection-43"><a href="#.E5.9C.A8.E5.AE.A2.E6.88.B7.E7.AB.AF.E5.92.8CBOSH.E6.9C.8D.E5.8A.A1.E4.B9.8B.E9.97.B4.E8.BF.9E.E6.8E.A5"><span class="tocnumber">19.1</span> <span class="toctext">在客户端和BOSH服务之间连接</span></a></li>
<li class="toclevel-2 tocsection-44"><a href="#BOSH.E5.92.8C.E5.BA.94.E7.94.A8.E4.B9.8B.E9.97.B4.E7.9A.84.E8.BF.9E.E6.8E.A5"><span class="tocnumber">19.2</span> <span class="toctext">BOSH和应用之间的连接</span></a></li>
<li class="toclevel-2 tocsection-45"><a href="#.E4.B8.8D.E5.8F.AF.E9.A2.84.E6.B5.8B.E7.9A.84SID.E5.92.8CRID"><span class="tocnumber">19.3</span> <span class="toctext">不可预测的SID和RID</span></a></li>
<li class="toclevel-2 tocsection-46"><a href="#.E4.BD.BF.E7.94.A8SHA-1"><span class="tocnumber">19.4</span> <span class="toctext">使用SHA-1</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-47"><a href="#IANA.E4.BA.8B.E9.A1.B9"><span class="tocnumber">20</span> <span class="toctext">IANA事项</span></a></li>
<li class="toclevel-1 tocsection-48"><a href="#XMPP.E6.B3.A8.E5.86.8C.E4.BA.8B.E9.A1.B9"><span class="tocnumber">21</span> <span class="toctext">XMPP注册事项</span></a>
<ul>
<li class="toclevel-2 tocsection-49"><a href="#.E5.8D.8F.E8.AE.AE.E5.91.BD.E5.90.8D.E7.A9.BA.E9.97.B4"><span class="tocnumber">21.1</span> <span class="toctext">协议命名空间</span></a></li>
</ul>
</li>
<li class="toclevel-1 tocsection-50"><a href="#XML_Schema"><span class="tocnumber">22</span> <span class="toctext">XML Schema</span></a></li>
<li class="toclevel-1 tocsection-51"><a href="#.E8.87.B4.E8.B0.A2"><span class="tocnumber">23</span> <span class="toctext">致谢</span></a></li>
<li class="toclevel-1 tocsection-52"><a href="#.E9.99.84.E5.BD.95"><span class="tocnumber">24</span> <span class="toctext">附录</span></a>
<ul>
<li class="toclevel-2 tocsection-53"><a href="#.E9.99.84.E5.BD.95A:.E6.96.87.E6.A1.A3.E4.BF.A1.E6.81.AF"><span class="tocnumber">24.1</span> <span class="toctext">附录A:文档信息</span></a></li>
<li class="toclevel-2 tocsection-54"><a href="#Appendix_B:_Author_Information"><span class="tocnumber">24.2</span> <span class="toctext">Appendix B: Author Information</span></a></li>
<li class="toclevel-2 tocsection-55"><a href="#.E9.99.84.E5.BD.95C:.E6.B3.95.E5.BE.8B.E9.80.9A.E5.91.8A"><span class="tocnumber">24.3</span> <span class="toctext">附录C:法律通告</span></a></li>
<li class="toclevel-2 tocsection-56"><a href="#.E9.99.84.E5.BD.95D:.E5.92.8CXMPP.E7.9A.84.E5.85.B3.E7.B3.BB"><span class="tocnumber">24.4</span> <span class="toctext">附录D:和XMPP的关系</span></a></li>
<li class="toclevel-2 tocsection-57"><a href="#.E9.99.84.E5.BD.95E:.E8.AE.A8.E8.AE.BA.E5.9C.B0.E7.82.B9"><span class="tocnumber">24.5</span> <span class="toctext">附录E:讨论地点</span></a></li>
<li class="toclevel-2 tocsection-58"><a href="#.E9.99.84.E5.BD.95F:.E9.9C.80.E6.B1.82.E4.B8.80.E8.87.B4.E6.80.A7"><span class="tocnumber">24.6</span> <span class="toctext">附录F:需求一致性</span></a></li>
<li class="toclevel-2 tocsection-59"><a href="#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8"><span class="tocnumber">24.7</span> <span class="toctext">附录G:备注</span></a></li>
<li class="toclevel-2 tocsection-60"><a href="#.E9.99.84.E5.BD.95H:.E4.BF.AE.E8.AE.A2.E5.8E.86.E5.8F.B2"><span class="tocnumber">24.8</span> <span class="toctext">附录H:修订历史</span></a></li>
</ul>
</li>
</ul>
</td></tr></table>
<h2> <span class="mw-headline" id=".E7.AE.80.E4.BB.8B">简介</span></h2>
<p>传输控制协议 (TCP; <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc0793">RFC 793</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">1</a> ) 经常用来建立两个实体之间的面向流的连接. 这些连接可以保持常连，使得实体之间的 "会话" 能够交互式的进行. 无论如何, 有时候设备或网络的性质可能会阻止一个应用程序去维护一个常连的TCP连接到一个服务器或对端. 在这种情况下, 需要使用一个替代的连接方法，使用排序的一系列请求和应答在短连的连接上交换信息来模拟常连的TCP连接. 通过 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc1945">RFC1945</a>  <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">2</a>  和 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc2616">RFC2616</a>  <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">3</a>  定义的超文本传输协议(HTTP)可以获得很多可用的合适的 请求-应答 语义.
</p><p>BOSH, 本文定义的这种技术, 实质上为常连的双向TCP连接提供了一个 "drop-in" 的替代品. 它是一个成熟的, 全功能的技术，自2004年以来已经被广泛实现和布署. 据我们所知它是众多类似技术中的第一个, 它现在包含了正规化的<a rel="nofollow" class="external text" href="http://svn.cometd.org/trunk/bayeux/bayeux.html">Bayeux协议</a> <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">4</a> 的 彗星(Comet) 方法(译者注：Comet就是Ajax web应用程序的服务器推送技术的结合)，以及 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol">Web Socket协议</a> <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">5</a> 和 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/draft-lentczner-rhttp">反向HTTP</a> <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">6</a>.
</p><p>BOSH被设计成有效地传输任何数据并且在两个方向上都保持最小延迟. 对应用程序来讲那同时需要 "推" 和 "拉" 语义, BOSH显然比其他大多数双向的基于HTTP的传输协议更节省带宽和响应更迅速，这个技术现在通常称为 "Ajax". BOSH通过对多个同步的"HTTP请求/响应对"使用所谓"长轮询"来达到高效. 此外, 通过使用不需要"cookies"而全兼容HTTP 1.0 (见 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc2965">RFC 2965</a> <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">7</a> ) <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">8</a> 或甚至访问HTTP头，BOSH可以解决受限客户端的需要 .
</p><p>BOSH原本是由 Jabber/XMPP 社区开发出来替代更早的基于HTTP的技术 <a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0025.html">Jabber HTTP轮询</a> <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">9</a> . 尽管BOSH假定HTTP请求和应答的 "载荷" 是XML, 载荷的格式未受XMPP节 (见 <a href="/RFC6120" title="RFC6120">XMPP Core</a> <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">10</a> ) 的限制,并且可以包含不同协议定义的命名空间的元素的混合物 (例如, 同时包含 XMPP 和 JSON). 这种混合是必要的，因为一些连接管理者可能不支持多重流，而受限的客户端经常无法访问HTTP流水线 (这限制同一时间只能拥有一个BOSH会话). BOSH连接管理者通常不需要理解它们所传输的XML的任何内容，除了确保每个XML载荷被正确的命名空间所限定.
</p><p>注意: <a href="/index.php?title=XEP-0206&amp;action=edit&amp;redlink=1" class="new" title="XEP-0206（尚未撰写）">XMPP Over BOSH</a> <a href="/index.php?title=XEP-0124%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-0124附录G:备注（尚未撰写）">11</a> 记录了一些以前包含在本协议中的XMPP特有的扩展.
</p>
<h2> <span class="mw-headline" id=".E9.9C.80.E6.B1.82">需求</span></h2>
<p>以下的设计需求反映了提供接近标准TCP连接的性能的需要.
</p>
<ol><li> 和受约束的运行时环境兼容* (例如, 手机和基于浏览器的客户端).
</li><li> 和缓冲了部分HTTP应答的代理兼容.
</li><li> 高效的通过那些限制HTTP响应时间的代理.
</li><li> 完全兼容HTTP/1.0.
</li><li> 兼容受限的网络连接 (例如, 防火墙, 代理, 以及网关).
</li><li> 容错 (例如, 在HTTP请求的任何阶段，底层TCP连接中断之后，会话恢复).
</li><li> 可扩展.
</li><li> 带宽消耗显著低于基于轮询的协议.
</li><li> 比基于轮询的协议显著快速响应 (低延迟).
</li><li> 支持轮询 (支持那些限制同一时间只有一个HTTP连接的客户端轮询).
</li><li> 顺序递送数据.
</li><li> 防范未经授权的用户会话注入HTTP请求.
</li><li> 防止拒绝服务攻击.
</li><li> 复用数据流.
</li></ol>
<ul><li>注意: 和受约束的运行环境兼容意味着以下限制:
</li></ul>
<ol><li> 客户端不需要编程访问每个HTTP请求和应答的头 (例如, cookies 或 状态码).
</li><li> 每个HTTP请求和应答的 body 是一个可解析的根元素的XML.
</li><li> 客户端可以指定它们接收的HTTP应答的 Content-Type.
</li></ol>
<h2> <span class="mw-headline" id=".E6.9E.B6.E6.9E.84.E5.81.87.E8.AE.BE">架构假设</span></h2>
<p>本文假定大部分实现使用专门的连接管理者 ("CM") 来处理HTTP连接，而非有关应用的本地连接类型 (例如, XMPP里的TCP连接). 为了效率, 这样一个连接管理者是一个专门的HTTP服务器，用来把这里定义的HTTP请求和应答和与之通讯的服务器实现的数据流(或API)之间进行翻译, 因此使得客户端能通过HTTP的80或443端口连接到一个服务器而不是一个特定应用的端口. 我们可以图形说明如下:
</p>
<pre>     服务器
       |
       |  [未封装的数据流]
       |
    HTTP连接管理器
       |
       |  [HTTP + &lt;body/&gt; 封装器]
       |
     客户端
   
</pre>
<p>本协议仅涵盖了客户端和连接管理器的通讯. 没有涉及连接管理器和服务器之间的通讯, 因为这类通讯是和特定实现相关的 (例如, 服务器可能原生支持HTTP绑定, 在这种情况下连接管理器是一个逻辑实体而不是物理实体; 另外连接管理器可以是独立翻译代理，这样该服务器认为它在直接和客户端通过TCP交谈; 或者连接管理器和服务器可能使用组件协议或服务器定义的API).
</p><p>此外, 本协议并没有限定只用于客户端和服务器之间的通讯. 例如, 它可以用于服务器之间的通讯，如果有关的应用(例如, 在XMPP里)发生了这样的通讯. 无论如何, 本文只专注于那些无法和服务器随时维护持久的TCP连接的客户端传输的使用. 我们假定服务器和组件不受那些限制，并且因此相关的应用将使用原生的连接传输. (无论如何, 在一些不可靠的网络中, BOSH可以让服务器之间的通讯更加稳定.)
</p>
<h2> <span class="mw-headline" id="BOSH.E6.8A.80.E6.9C.AF">BOSH技术</span></h2>
<p>因为HTTP是一个同步请求/应答协议, 传统的通过HTTP模拟双向流的解决方案是让客户端HTTP间歇性地轮询连接管理器来查询是否有任何等待发送给客户端的数据. 当没有数据需要传输的时候，这种幼稚的做法在轮询的时候浪费了很多网络带宽. 它也降低了应用程序的响应，因为数据要花时间排队直到连接管理器从客户端接收下一次轮询 (HTTP 请求) . 这导致了响应速度和带宽之间难免顾此失彼, 因为增加轮询频率将在减少延迟的同时增加带宽消耗 (如果轮询频率降低的话，反之亦然).
</p><p>BOSH使用的技术通过鼓励连接管理器在它确实有数据发送给客户端之前不去应答请求,同时达到低延迟和低带宽消耗的目的. 一旦客户端从连接管理器接收到一个应答，它发送另一个请求, 从而确保连接管理器 (几乎) 总是持有一个可以用来 "推送" 数据给客户端的请求.
</p><p>如果客户端需要发送一些数据给连接管理器，那么它只要简单地发送第二个包含数据的请求. 不幸的是大部分受约束的客户端不支持HTTP流水线 (通过单个的连接的并发请求), 所以客户端通常需要通过第二个HTTP连接发送这个数据. 连接管理器总是应答它持有的第一个连接的请求，一旦从客户端接收到一个新的请求 -- 甚至即使没有数据发送给客户端. 它这么做可以确保客户端能在必要的时候立刻发送更多数据. (客户端同一时间不应该打开超过两个HTTP连接到连接管理器, <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">12</a> ,否则它不得不等待连接管理器应答请求中的一个.)
</p><p>即使网络情况迫使每个HTTP请求都要通过不同的TCP连接，BOSH也会可靠地工作. 无论如何, 如果经常发生这种情况, 客户端可以使用HTTP/1.1, 然后 (假定网络情况稳定) 一个会话中的所有请求将在同样的两个持久TCP连接上通过. 几乎任何时候 (见下文) 客户端都可以推送数据到这两个连接中的一个, 而连接管理器能推送数据到另一个连接 (所以延迟和一个标准的TCP连接一样低). 有意思的是，注意这两个连接的角色每当客户端发送数据到连接管理器的时候就会互换.
</p><p>如果在一个规定时间内(通常是几分钟)两个方向上都没有流量, 那么连接管理器以无数据来应答客户端, 并且那个应答立即触发一个新的客户端请求. 连接管理器这么做来确认是否网络连接已经中断，并且双方都在一个合理的时间内明白到这一点. 这一交换类似大部分持久TCP连接中的通用的 "keep-alive" 或 "ping" . 因为BOSH技术未使用轮询, 带宽消耗不会比标准TCP连接大很多. <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">13</a>
</p><p>大部分时候数据可以被立刻推送. 无论如何, 如果其中一个端点刚推送了一些数据，在它再次推送之前将不得不等待网络往返. 如果客户端可以使用HTTP流水线，那么就可以拥有多个并发的请求了. 这样客户端就总能立刻推送数据了. 它也能保证连接管理器总是持有足够的请求，这样甚至在连续发送的时候它也绝不需要在发送数据之前等待. 此外, 如果连接管理器持有的请求池太大, 那么客户端从连接管理器接收数据之后在压力之下将不能立刻发送一个新的空请求. 它只能等待，除非需要发送数据. 所以, 如果随着时间的推移，客户端接收和发出的流量平衡了, 带宽消耗将和使用标准的TCP连接相同.
</p><p>连接管理器推送的每一个数据块都是一个完整的HTTP应答. 所以, 和Comet技术不像, BOSH技术是通过中间代理缓冲部分HTTP请求来工作的. 它也完全兼容HTTP/1.0 -- 不提供分块传输编码.
</p>
<h2> <span class="mw-headline" id="HTTP.E6.A6.82.E8.BF.B0">HTTP概述</span></h2>
<p>所有信息被编码到标准的HTTP POST请求和应答的body中. 每个HTTP body包含一个单独的 &lt;body/&gt; 封装器用来封装被传输的XML元素 (见 <a href="/XEP-0124#.3Cbody.2F.3E.E5.B0.81.E8.A3.85.E5.99.A8.E5.85.83.E7.B4.A0" title="XEP-0124">XEP-0124#&lt;body/&gt;封装器元素</a> ).
</p><p>客户端应该使用HTTP流水线通过一个持久的HTTP/1.1连接发送所有的HTTP请求. 不过, 客户端也可以用任何 <b><a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc1945">RFC 1945</a></b> 或 <b><a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2616">RFC 2616</a></b> 允许的方式递送这些POST请求. 例如, 受约束的客户端可能期望打开不止多个持久连接而不是使用HTTP流水线, 或者在某些情况下打开一个新的HTTP/1.0连接来发送每个请求. 无论如何, 客户端和连接管理器不应该使用分块传输编码, 因为中间代理可能缓冲每部分的HTTP请求或应答并且在可以发送的时候只传输完整的请求或应答.
</p><p>客户端可以在任何请求中包含一个HTTP Accept-Encoding头. 如果连接管理器接收到一个拥有Accept-Encoding头的请求, 它可以在应答中包含一个HTTP Content-Encoding头 (指定请求中说明的编码之一) 并据此压缩应答body.
</p><p>请求和应答可以包含未在本文提到的HTTP头. 接收者应该忽略那些HTTP头.
</p><p>每个BOSH会话可以分享其他用途的HTTP流量的HTTP连接, 包括其他BOSH会话以及和本协议完全无关的HTTP请求和应答 (例如, web页面下载). 无论如何, 使用HTTP流水线通过同一个连接对不是本会话一部分的请求的应答(或同一个连接中的发送队列)可能会导致对于本会话的一部分的请求的应答的延迟 (因为连接管理器必须以和接收到的请求相同的顺序来发送它的应答, 并且连接管理器通常会延迟它的某些应答).
</p><p>所有客户端请求的HTTP Content-Type头应该是 "text/xml; charset=utf-8". 无论如何, 如果客户端受到某些约束，它们也可以指定其他的值 (例如, "application/x-www-form-urlencoded" 或 "text/plain"). 客户端和连接管理器应该忽略所有接收到的HTTP Content-Type头.
</p>
<h2> <span class="mw-headline" id=".3Cbody.2F.3E.E5.B0.81.E8.A3.85.E5.99.A8.E5.85.83.E7.B4.A0">&lt;body/&gt;封装器元素</span></h2>
<p>每个HTTP请求和应答的body包含一个单独的由 '<a rel="nofollow" class="external free" href="http://jabber.org/protocol/httpbind'">http://jabber.org/protocol/httpbind'</a> 命名空间限定的&lt;body/&gt;封装器元素. 这个封装器的内容就是被传输的数据. &lt;body/&gt;元素和它的内容都必须符合 <a rel="nofollow" class="external text" href="http://www.w3.org/TR/REC-xml/">XML 1.0</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">14</a> 的一系列规格. 它们也应该符合 <a rel="nofollow" class="external text" href="http://www.w3.org/TR/REC-xml-names/">Namespaces in XML</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">15</a>. 内容必须不包含任何以下的东西 (都定义于 <b>XML 1.0</b> ):
</p>
<ul><li> 部分XML元素
</li><li> XML注释
</li><li> XML处理指令
</li><li> 内部或外部DTD亚群
</li><li> 内部或外部实体引用 (预定义的实体除外)
</li></ul>
<p>&lt;body/&gt;封装器必须不包含任何XML字符串数据, 尽管它的子元素可以包含字符串数据. &lt;body/&gt;封装器必须包含零或多个完整的XML直接子元素(本文称为 "载荷" , 例如, 定义于 <b><a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc6120">RFC 6120</a></b> 的XMPP节或使用定义于 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc4627">RFC 4627</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">16</a> 的JSON数据交换格式来代表对象的包含XML字符串数据的元素).每个&lt;body/&gt;封装器可以包含各种广泛的命名空间限定的载荷.
</p><p>每个客户端请求的&lt;body/&gt;元素必须拥有一个通过'rid'属性封装的顺序的请求ID; 具体信息, 参考本文的 <a href="/XEP-0124#.E8.AF.B7.E6.B1.82IDs" title="XEP-0124">请求IDs</a> 章节.
</p>
<h2> <span class="mw-headline" id=".E5.8F.91.E8.B5.B7BOSH.E4.BC.9A.E8.AF.9D">发起BOSH会话</span></h2>
<h3> <span class="mw-headline" id=".E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E8.AF.B7.E6.B1.82">会话创建请求</span></h3>
<p>从客户端到连接管理器的第一个请求是请求一个新的会话.
</p><p>第一个请求的&lt;body/&gt;元素应该拥有以下属性 (它们应该不被包含在其他请求中，除非在 <a href="/XEP-0124#.E6.B7.BB.E5.8A.A0.E6.B5.81.E5.88.B0.E4.B8.80.E4.B8.AA.E4.BC.9A.E8.AF.9D" title="XEP-0124">添加流到一个会话</a> 时候指定):
</p>
<ul><li> <b>'to'</b> -- 这个属性指定第一个流的目标域.
</li><li> <b>'xml:lang'</b> -- 这个属性 (定义于 <a rel="nofollow" class="external text" href="http://www.w3.org/TR/REC-xml/">XML 1.0</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">17</a> 的2.12) 指定会话期间发送或接收的任何人类可读的字符串数据的缺省语言.
</li><li> <b>'ver'</b> -- 这个属性指定客户端支持的BOSH协议的最高版本. 编号方案是 "&lt;主版本号&gt;.&lt;小版本号&gt;" (这里小版本号可以递增到不止一位数子, 所以它必须被当成一个单独的整数来处理). 注意: 'ver' 属性应该不被误解成任何正被传输的协议的版本.
</li><li> <b>'wait'</b> -- 这个属性指定连接管理器在会话中应答任何请求之前被允许的等待时间(以秒计数). 这使客户端能限制它察觉任何网络失败之前的延迟, 并且阻止它的HTTP/TCP连接因为不活跃而过期.
</li><li> <b>'hold'</b> -- 这个属性指定连接管理器在会话中被允许同时保持的请求的最大数量. 如果客户端不能使用HTTP流水线那么它应该设为 "1".
</li></ul>
<p>注意: 仅支持轮询会话的客户端可以通过设置'wait' 或 'hold' 为 "0" 来阻止连接管理器等待. 无论如何, 轮询是不推荐的，因为带宽消耗的增加和响应能力的降低都会达到一到两个数量级!
</p><p>连接管理器可以被配置成允许在不同的域里和多个服务器进行会话. 当以一个"代理"连接管理器请求一个会话的时候, 客户端应该包含一个'route'属性来指定它想通讯的服务器的协议, 主机名, 和端口, 格式为 "proto:host:port" (例如, "xmpp:example.com:9999"). <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">18</a> 一个配置成只和一个 (或只和预定义的域列表以及服务于那些域的相关主机和端口列表的) 服务器配合工作的连接管理器可以忽略 'route' 属性. (注意 'to' 属性指定服务的域, 而不是服务于那个域的机器的主机名.)
</p><p>第一个请求的 &lt;body/&gt; 元素也可以拥有 'from' 属性, 它指定第一个流的发起者并允许连接管理器转发发起者实体的身份到应用服务器 (例如, 连接到一个XMPP服务器上的实体的 JabberID&#160;; 见 <b>XEP-0206</b> ).
</p><p>客户端可以包含一个 'ack' 属性 (设为 "1") 来指示它将在会话中始终使用确认机制并且任何请求中缺少'ack'属性都是有特定意义的 (见 <a href="/XEP-0124#.E7.A1.AE.E8.AE.A4" title="XEP-0124">确认</a> ).
</p><p>一些客户端被约束只能接受特定Content-Types (例如, "text/html")的HTTP应答. 第一个请求的&lt;body/&gt;元素可以拥有一个'content'属性. 它指定在会话期间必须在所有连接管理器的应答中出现的HTTP Content-Type头的值. 如果该客户端请求没有'content'属性, 那么应答的HTTP Content-Type头必须是"text/xml; charset=utf-8".
</p><p><b>示例1. 请求一个BOSH会话</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 104
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">content</span>=<span class="st0">'text/xml; charset=utf-8'</span>
      <span class="re0">from</span>=<span class="st0">'user@example.com'</span>
      <span class="re0">hold</span>=<span class="st0">'1'</span>
      <span class="re0">rid</span>=<span class="st0">'1573741820'</span>
      <span class="re0">to</span>=<span class="st0">'example.com'</span>
      <span class="re0">route</span>=<span class="st0">'xmpp:example.com:9999'</span>
      <span class="re0">ver</span>=<span class="st0">'1.6'</span>
      <span class="re0">wait</span>=<span class="st0">'60'</span>
      <span class="re0">ack</span>=<span class="st0">'1'</span>
      <span class="re0">xml:lang</span>=<span class="st0">'en'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>注意: 在第一个之后的所有请求必须包含一个有效的'sid'属性 (由连接管理器在会话创建应答中提供). 发起方请求是唯一的，在那个&lt;body/&gt;元素中必须没有'sid'属性.
</p>
<h3> <span class="mw-headline" id=".E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E5.BA.94.E7.AD.94">会话创建应答</span></h3>
<p>在接收到到一个新的会话请求之后, 连接管理器必须生成一个不透明的不可预测的会话标识符 (或称为 SID). 这个SID在该连接管理器应用中的上下文中必须是唯一的. 该连接管理器对客户端的会话创建请求的应答中的 &lt;body/&gt; 元素必须拥有以下属性 (它们应该不被包含在任何其他应答中):
</p>
<ul><li> <b>'sid'</b> -- 该属性指定SID
</li><li> <b>'wait'</b> -- 这是连接管理器在会话期间应答任何请求之前等待的最长时间 (以秒计数) . 这个时间必须小于或等于该会话请求的指定的值.
</li></ul>
<p>&lt;body/&gt;元素也应该包含以下属性 (它们应该不被包含在任何其他应答中):
</p>
<ul><li> <b>'ver'</b> -- 这个属性指定连接管理器支持的BOSH协议的最高版本, 或客户端在它的请求中指定的版本, 取其中较低的版本.
</li><li> <b>'polling'</b> -- 这个属性指定最小可允许的轮询间隔(以秒计数). 这使得客户端不需要以超出预期的频率发送空的请求元素 (见 <a href="/XEP-0124#.E8.BD.AE.E8.AF.A2.E4.BC.9A.E8.AF.9D" title="XEP-0124">轮询会话</a> 和 <a href="/XEP-0124#.E8.BF.87.E5.BA.A6.E6.B4.BB.E8.B7.83" title="XEP-0124">过度活跃</a> ).
</li><li> <b>'inactivity'</b> -- 这个属性指定最长可允许的闲置期时间(以秒计数). 这使客户端能确保没有请求待发的时间段永远不会太长 (见 <a href="/XEP-0124#.E8.BD.AE.E8.AF.A2.E4.BC.9A.E8.AF.9D" title="XEP-0124">轮询会话</a> 和 <a href="/XEP-0124#.E9.97.B2.E7.BD.AE" title="XEP-0124">闲置</a> ).
</li><li> <b>'requests'</b> -- 这个属性使得连接管理器能限制客户端产生的并发请求的数量 (见  <a href="/XEP-0124#.E8.BF.87.E5.BA.A6.E6.B4.BB.E8.B7.83" title="XEP-0124">过度活跃</a> 和 <a href="/XEP-0124#.E8.BD.AE.E8.AF.A2.E4.BC.9A.E8.AF.9D" title="XEP-0124">轮询会话</a> ). 推荐的值是 "2" 或者比会话请求中指定的'hold' 属性值大一.
</li><li> <b>'hold'</b> -- 这个属性通知客户端连接管理器在会话期间的任何时间将会保持等待的请求的最大数量. 这个值必须不大于客户端在会话请求中指定的值.
</li><li> <b>'to'</b> -- 这个属性指定客户端尝试连接的后台服务器的通讯身份.
</li></ul>
<p>连接管理器可以在会话创建应答元素中包含一个'accept'属性, 来指定一个以空格分隔的可被解压的内容编码的列表. 在接收到一个带有'accept'属性的会话创建应答之后, 客户端可以在随后的请求中包含一个HTTP Content-Encoding头 (指示 'accept' 属性指定的编码之一) 并且据此压缩该请求的bodies.
</p><p>连接管理器可以包含一个'ack'属性 (值设为会话创建请求中的'rid'属性值) 来指示它将在该会话中始终使用确认机制，并且任何应答中缺少'ack'属性都是有特定意义的 (见 <a href="/XEP-0124#.E7.A1.AE.E8.AE.A4" title="XEP-0124">确认</a> ).
</p><p>如果连接管理器支持会话暂停 (见 <a href="/XEP-0124#.E9.97.B2.E7.BD.AE" title="XEP-0124">闲置</a> ) 那么它应该通过在会话创建应答元素中包含一个'maxpause'属性来向客户端声明. 这个属性的值指示客户端可以请求的一个临时会话暂停的最大长度(以秒计数) .
</p><p>对请求和应答都一样, &lt;body/&gt;元素和它的内容应该以UTF-8编码. 如果请求/应答的HTTP Content-Type头指定了一个不同于UTF-8的字符编码, 那么连接管理器可以在UTF-8和该字符编码之间转换. 无论如何, 即使在这种情况下, 连接管理器转换编码也是可选的. 连接管理器可以通知客户端哪些编码它能够转换，通过在会话创建应答元素中设置可选的'charsets'属性为以空格分隔的编码列表. <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">19</a>
</p><p>一旦连接管理器建立了一个连接到服务器并发现它的身份, 它可以在应答中包含一个'from'属性来转发这个身份给客户端, 要么在它的会话创建应答中, 要么 (如果那个时候它还没有从服务器接收到它的身份) 任何随后给客户端的应答中. 如果它建立了一个安全连接到服务器 (定义于 <a href="/XEP-0124#.E5.8F.91.E8.B5.B7BOSH.E4.BC.9A.E8.AF.9D" title="XEP-0124">发起BOSH会话</a> ), 那么在同一个应答中连接管理器也应该包含'secure'属性并把值设为 "true" 或 "1".
</p><p><b>示例2. 会话创建应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 128
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">wait</span>=<span class="st0">'60'</span>
      <span class="re0">inactivity</span>=<span class="st0">'30'</span>
      <span class="re0">polling</span>=<span class="st0">'5'</span>
      <span class="re0">requests</span>=<span class="st0">'2'</span>
      <span class="re0">hold</span>=<span class="st0">'1'</span>
      <span class="re0">ack</span>=<span class="st0">'1573741820'</span>
      <span class="re0">accept</span>=<span class="st0">'deflate,gzip'</span>
      <span class="re0">maxpause</span>=<span class="st0">'120'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">charsets</span>=<span class="st0">'ISO_8859-1 ISO-2022-JP'</span>
      <span class="re0">ver</span>=<span class="st0">'1.6'</span>
      <span class="re0">from</span>=<span class="st0">'example.com'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p><b>示例3. 随后的包含'from'和'secure'属性的应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 128
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">from</span>=<span class="st0">'example.com'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<h2> <span class="mw-headline" id=".E5.8F.91.E9.80.81.E5.92.8C.E6.8E.A5.E6.94.B6XML.E8.BD.BD.E8.8D.B7">发送和接收XML载荷</span></h2>
<p>客户端成功完成所有必需的前提条件之后, 它就可以通过HTTP绑定来发送和接收XML载荷了.
</p><p><b>示例4. 传输载荷</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243562'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;message</span> <span class="re0">to</span>=<span class="st0">'contact@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">Good morning!</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
  <span class="re1">&lt;message</span> <span class="re0">to</span>=<span class="st0">'friend@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">Hey, what</span><span class="co4">&amp;apos;</span><span class="co3">s up?</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<p>在收到一个请求之后，一旦有可能连接管理器应该转发&lt;body/&gt;元素的内容到服务器. 在任何情况下它必须按照它们的'rid'属性指定的顺序来从不同的请求转发内容.
</p><p>连接管理器也必须在&lt;body/&gt;元素中返回一个HTTP 200 OK应答给客户端. 注意: 这并不表示载荷已经被成功发送到应用服务器.
</p><p>建议连接管理器在载荷已经从服务器到达客户端之前不要返回HTTP结果. 无论如何, 连接管理器不应该让等待时间超过客户在它的会话创建请求中指定的'wait'属性的值 , 而且在同一时间它保持的HTTP请求数量不应该多于会话创建请求中的'hold'属性的值. 任何情况下它必须以它们的'rid'属性指定的顺序来应答请求.
</p><p>如果在等待周期里没有载荷等待或准备好发送, 那么连接管理器应该在HTTP结果中包含一个空的&lt;body/&gt;元素:
</p><p><b>示例5. 空应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 64
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>如果连接管理器已经从应用服务器收到一个或多个载荷要发送给客户端, 那么在它从服务器收到它们之后一旦有可能它应该立即在它的应答的body中返回这些载荷. 以下这个例子包含被不同命名空间限定的载荷:
</p><p><b>示例6. 排队节的应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 185
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span>
      <span class="re0">xmlns:json</span>=<span class="st0">'http://json.org/'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;message</span> <span class="re0">from</span>=<span class="st0">'contact@example.com'</span>
           <span class="re0">to</span>=<span class="st0">'user@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">Good morning to you!</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
  <span class="re1">&lt;message</span> <span class="re0">from</span>=<span class="st0">'friend@example.com'</span>
           <span class="re0">to</span>=<span class="st0">'user@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">Not much, how about with you?</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
  <span class="re1">&lt;json:json<span class="re2">&gt;</span></span><span class="co3">
  [
    {
      &quot;precision&quot;: &quot;zip&quot;,
      &quot;Latitude&quot;:  37.7668,
      &quot;Longitude&quot;: -122.3959,
      &quot;Address&quot;:   &quot;&quot;,
      &quot;City&quot;:      &quot;SAN FRANCISCO&quot;,
      &quot;State&quot;:     &quot;CA&quot;,
      &quot;Zip&quot;:       &quot;94107&quot;,
      &quot;Country&quot;:   &quot;US&quot;
    },
    {
      &quot;precision&quot;: &quot;zip&quot;,
      &quot;Latitude&quot;:  37.371991,
      &quot;Longitude&quot;: -122.026020,
      &quot;Address&quot;:   &quot;&quot;,
      &quot;City&quot;:      &quot;SUNNYVALE&quot;,
      &quot;State&quot;:     &quot;CA&quot;,
      &quot;Zip&quot;:       &quot;94085&quot;,
      &quot;Country&quot;:   &quot;US&quot;
    }
  ]
  </span><span class="re1">&lt;/json:json<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<p>客户端可以通过发送空的&lt;body/&gt;元素来轮询连接管理器的输入节.
</p><p><b>示例7. 请求XML载荷</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 88
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243563'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>连接管理器必须以和它从客户端接收载荷同样的方法等待并回应.
</p>
<h2> <span class="mw-headline" id=".E7.A1.AE.E8.AE.A4">确认</span></h2>
<h3> <span class="mw-headline" id=".E8.AF.B7.E6.B1.82.E7.A1.AE.E8.AE.A4">请求确认</span></h3>
<p>当应答一个保持的请求时, 如果连接管理器发现它已经接收了另一个更高'rid'属性的请求(通常此时它正在保持第一个请求), 那么它可以向客户端确认已收到. 当连接管理器也接收了所有更低的'rid'属性的请求时，它可以设置任何应答的 'ack' 属性高于它已经接收到的最高的'rid'属性.
</p><p><b>示例8. 应答请求的确认</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 64
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">ack</span>=<span class="st0">'1249243564'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>如果连接管理器在一个会话过程中将要包含'ack'属性, 那么它必须在它的会话创建应答中包含一个'ack'属性, 并且在会话过程中始终设置应答的'ack'属性. 唯一的例外是, 在它的会话创建应答之后, 如果这个值和任何要应答的请求的'rid'值相同，连接管理器不应该包含一个'ack'属性在应答之中.
</p><p>如果连接管理器被允许同一时间保持多个请求, 那么从连接管理器收到低于预期的'ack'值(或意外的缺少'ack'属性)可以给客户端一个可能发生网络失败的早期预警(例如, 如果客户端认为连接管理在它应答的时候应该已经接收到了另一个请求).
</p>
<h3> <span class="mw-headline" id=".E5.BA.94.E7.AD.94.E7.A1.AE.E8.AE.A4">应答确认</span></h3>
<p>客户端可以同样通过把任何请求的'ack'属性值设为它已经接收到的的应答的最高'rid'值(此时它也已经接收了所有拥有更低'rid'值的应答)来通知连接管理器它已经收到了应答. 如果客户端在一个会话中要在请求中包含'ack'属性, 那么它必须在它的会话创建请求中包含一个'ack'属性(值为'1'), 并且在会话中始终设置请求的'ack'属性. 唯一的例外是, 在它的会话创建请求之后, 如果客户端已经接收到所有在它之前的请求的应答，那么客户端不应该包含一个'ack'属性到任何请求.
</p><p><b>示例9. 请求应答确认</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 88
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243566'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">ack</span>=<span class="st0">'1249243564'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>在接收到一个'ack'值低于最后一个已应答请求的'rid'值的请求时, 连接管理器可以通过立即发送它的下一个应答而不是等到它有需要发送给客户端的载荷的时候才发送应答(例如, 假如从它应答的时候到现在已经过了一段时间)，以此告知客户端这种情况. 在这种情况下它应该包含一个'report'属性并把值设为高于它从客户端接收到的'ack'属性, 而'time'属性则设为它发送'report'相关应答的时间，以毫秒计数.
</p><p><b>示例10. 应答报告</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 64
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">report</span>=<span class="st0">'1249243565'</span>
      <span class="re0">time</span>=<span class="st0">'852'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>在收到一个拥有'report'和'time'属性的应答之后, 如果客户端仍未收到'report'属性指定的请求id相关的应答, 那么它可以选择重发这个丢失的应答相关的请求 (见 <a href="/XEP-0124#.E6.96.AD.E5.BC.80.E7.9A.84.E8.BF.9E.E6.8E.A5" title="XEP-0124">断开的连接</a> ).
</p>
<h2> <span class="mw-headline" id=".E9.97.B2.E7.BD.AE">闲置</span></h2>
<p>从连接管理器接收到一个应答之后, 如果没有客户端请求继续被连接管理器保持 (并且如果会话不是一个轮询会话), 客户端应该一有可能就制造一个新的请求. 在任何情况下, 如果没有请求被hold住, 客户端必须在最大闲置时间过期之前制造一个新的请求. 这个时间段(以秒计数) 是在会话创建应答中的'inactivity'属性定义的.
</p><p>如果连接管理器已经应答了一个会话中它所接收到的所有请求并且从最后一次应答到当前的时间超过最大闲置时间段, 那么它应该假定客户端已经失去连接并且不通知客户端就终止这个会话. 如果接下来客户端再制造另一个请求, 那么连接管理器应该像这个会话不存在一样来应答.
</p><p>如果连接管理器在会话创建应答里没有指定一个最大闲置时间, 那么它应该允许客户端选择它的闲置时间.
</p><p>如果会话不是轮询会话那么连接管理器应该指定一个相对短的闲置时间来确保尽可能快的发现断链. 建议的时间应该比连接管理器和客户端在困难的网络条件下一次顺利的网络往返的秒数多一点 (因为可以期待客户端立刻制造一个新请求 -- 见上文).
</p><p>如果客户端遇到意外的临时状况，在此期间它将不能在最大闲置时间之内发送请求到连接管理器(例如, 当运行时环境从一个web页面变成另一个页面), 并且如果连接管理器在它的会话创建应答中包含了'maxpause'属性, 那么客户端可以通过在一个请求中包含'pause'属性来请求临时增加最大闲置时间的. 注意: 如果连接管理器没有在会话开始的时候定义一个'maxpause'属性那么客户端不能在会话期间发送'pause'属性.
</p><p><b>示例11. 请求会话暂停</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 98
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243564'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">pause</span>=<span class="st0">'60'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>接收到一个会话暂停请求之后, 如果请求的时间段不超过最大允许时间, 那么连接管理器应该立刻应答所有未决的请求(包括暂停请求)并临时增加最大限制时间到请求的时间. 注意: 对暂停请求的应答不能包含任何载荷.
</p><p>注意: 如果客户端简单地希望连接管理器返回所有它保持住的请求，那么它可以把'pause'属性值设为连接管理器的会话请求应答中的'inactivity'属性值. (如果客户端认为它有无限期断线的危险，那么它甚至可以通过指定一个小于'inactivity'值的'pause'值来请求临时减少闲置时间, 这样使得连接管理器能快速发现接下来的断链.)
</p><p>连接管理器应该在从客户端接到下一个请求之前(假定连接管理器尚未终止该会话)把闲置时间设回正常.
</p>
<h2> <span class="mw-headline" id=".E8.BF.87.E5.BA.A6.E6.B4.BB.E8.B7.83">过度活跃</span></h2>
<p>客户端不应该制造超过连接管理器的会话创建应答中的'requests'属性定义数量的并发请求. 无论如何，如果客户端暂停或终止一个会话，它可以制造一个额外的请求.
</p><p>如果在任何时间段客户端发送系列的新请求(也就是说请求的rid属性是增长的, 而不是重复的请求)超过了'requests'属性指定的数量, 并且如果连接管理器尚未应答这些请求中的任何一个, 并且如果最后一次请求既不包含一个'pause'属性也不包含一个值为"terminate"的'type'属性, 那么连接管理器应该认为客户端正在制造过多的并发请求, 并且发一个'policy-violation'终止绑定错误给客户端来终止该HTTP会话. 注意: 这个行为同时适用于普通和轮询会话.
</p><p><b>示例12. 过多并发请求应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'policy-violation'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>注意: 如果连接管理器在会话创建应答中没有指定一个'requests'属性, 那么它必须允许客户端按它选择的数量来发送并发请求.
</p><p>如果在任何时间段客户端发送系列新请求等于'requests'属性指定的数量, 并且如果连接管理器尚未应答这些请求中的任何一个, 并且如果最后一次请求既不包含一个'pause'属性也不包含一个值为"terminate"的'type'属性, 并且最后两个请求到达的时间差小于创建会话应答中的'polling'属性定义的值, 那么连接管理器应该认为客户端正在制造超过它允许的频率的请求并且发一个'policy-violation'终止绑定错误给客户端来终止该HTTP会话. 注意: 这个行为对于轮询会话略有不同.
</p><p><b>示例13. 过于频繁的请求应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'policy-violation'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>注意: 如果连接管理器在会话创建应答中未定义'polling'属性, 那么它必须允许客户端按它选择的频率来发送请求.
</p>
<h2> <span class="mw-headline" id=".E8.BD.AE.E8.AF.A2.E4.BC.9A.E8.AF.9D">轮询会话</span></h2>
<p>对一个受约束的客户端来说不一定总是能使用HTTP流水线或在同一时间和连接管理器打开多个HTTP连接. 在这种情况下客户端应该在它的会话创建请求中把'wait' 和/或 'hold' 属性值设为"0"来通知连接管理器, 并且然后在会话中始终有规律地"轮询"连接管理器来获得它可能从服务器收到的载荷. 注意: 即使客户端不请求一个轮询会话, 连接管理器可以通过设置它的 <a href="/XEP-0124#.E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E5.BA.94.E7.AD.94" title="XEP-0124">会话创建应答</a> 的'requests'属性(它指定客户端能制造的并发请求的数量)为"1"来要求一个客户端使用轮询, 无论如何这是不推荐的.
</p><p>如果一个会话将使用轮询, 连接管理器应在它的会话创建应答中指定一个高于普通值的'inactivity'属性(见 <a href="/XEP-0124#.E9.97.B2.E7.BD.AE" title="XEP-0124">闲置</a> ) . 这个增加值应该大于它指定的'polling'属性值.
</p><p>如果客户端在一个低于会话创建应答中'polling'属性(允许的最短轮询间隔)指定的秒数的时间段内发送两个连续的空的新请求(也就是说请求的rid属性是增加的, 而不是重复的请求), 并且如果连接管理器应答的第一个请求不包含载荷, 那么在收到第二个请求之后连接管理器应该终止HTTP会话并返回一个'policy-violation'终止绑定错误给客户端.
</p><p><b>示例14. 过于频繁的轮询应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'policy-violation'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>注意: 如果连接管理器在会话创建应答中未指定'polling'属性, 那么它必须允许客户端按它选择的频率来轮询.
</p>
<h2> <span class="mw-headline" id=".E7.BB.88.E6.AD.A2HTTP.E4.BC.9A.E8.AF.9D">终止HTTP会话</span></h2>
<p>任何时候, 客户端可以发送一个'type'属性为"terminate"的&lt;body/&gt;元素来正常地终止会话. 终止请求可以包含一个或多个载荷，连接管理器必须转发给服务器以确保正常的注销登录.
</p><p><b>示例15. 来自客户端的会话终止</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 153
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243565'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;presence</span> <span class="re0">type</span>=<span class="st0">'unavailable'</span>
            <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">/&gt;</span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<p>连接管理器应该用一个包含空的&lt;body/&gt;元素的HTTP 200 OK来应答这个请求  .
</p><p><b>示例16. 连接管理器确认终止</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 72
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>在接收到该应答后, 客户端必须认为该HTTP会话已经被终止.
</p>
<h2> <span class="mw-headline" id=".E8.AF.B7.E6.B1.82IDs">请求IDs</span></h2>
<h3> <span class="mw-headline" id=".E7.94.9F.E6.88.90">生成</span></h3>
<p>客户端必须生成一个大的, 随机的, 正整数用于初始的'rid' (见 <a href="/XEP-0124#.E5.AE.89.E5.85.A8.E4.BA.8B.E9.A1.B9" title="XEP-0124">安全事项</a> ) ，并且随后的每个请求的rid做加一的处理. 客户端必须小心选择一个初始的'rid',在整个会话中它的值不能够加到超过 9007199254740991 <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">21</a> . 在实践中, 一个会话可能被迫变得非常长 (或涉及到非常多的包交换) 以至于超过定义的限制.
</p>
<h3> <span class="mw-headline" id=".E9.A1.BA.E5.BA.8F.E7.9A.84.E6.B6.88.E6.81.AF.E8.BD.AC.E5.8F.91">顺序的消息转发</span></h3>
<p>当一个客户端制造了并发请求, 连接管理器可能没能按顺序接收到它们. 连接管理器必须按照'rid'属性指定的顺序来转发载荷到服务器并应答客户端的这些请求. 客户端必须按照请求的顺序来处理从连接管理器接收到的应答.
</p><p>连接管理器应该期望'rid'属性值在一个大于前一个请求的数值窗内. 这个数值窗等于连接管理器允许的最大并发请求数量. 如果它接收到的请求的'rid'大于这个数值窗, 那么连接管理器必须以一个错误来终止会话:
</p><p><b>示例17. 意外的rid错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'item-not-found'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<h3> <span class="mw-headline" id=".E6.96.AD.E5.BC.80.E7.9A.84.E8.BF.9E.E6.8E.A5">断开的连接</span></h3>
<p>不可靠的网络通讯或客户端约束可能造成断开的连接. 连接管理器应该记住'rid'以及相应的那些客户端的非暂停请求(见 ［［XEP－0124＃闲置|闲置]] )和非HTTP或绑定错误的请求的HTTP应答. 保持在缓冲之中的对于非暂停请求的应答的数量应该和连接管理器允许的并发请求数量相同, 或者，如果使用了确认机制, 则和还未确认的应答数量相同.
</p><p>如果网络连接中断或在客户端接收到连接管理器对于某个请求的应答之前关闭了, 那么客户端刻一重新发送一个原请求的精确副本. 任何时候连接管理器发现收到的请求的'rid已经接收过, 它应该返回一个包含缓冲区的原有XML应答的 HTTP 200 (OK) 应答给客户端 (也就是说, 一个封装了了拥有适当属性以及可选的包含一个或多个XML载荷的&lt;body/&gt;). 如果原有的应答不可用 (例如, 它已经不在缓冲区了), 那么连接管理器必须返回一个 'item-not-found' 终止绑定错误:
</p><p><b>示例18. 应答不在缓冲区错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'item-not-found'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>注意: 无论这个'rid'是过大还是过小，错误都是一样的. 这使得攻击者更难搜索到可接受的值.
</p>
<h2> <span class="mw-headline" id=".E4.BF.9D.E6.8A.A4.E4.B8.8D.E5.AE.89.E5.85.A8.E7.9A.84.E4.BC.9A.E8.AF.9D">保护不安全的会话</span></h2>
<h3> <span class="mw-headline" id=".E9.80.82.E7.94.A8.E6.80.A7">适用性</span></h3>
<p>如果客户端和连接管理器之间的会话不安全，可以使用这里描述的可选的密钥序列机制. 只有所有客户端请求都是通过 SSL(或 TLS) HTTP连接并且连接管理器生成了一个不可预知的会话ID，该会话才应该被认为是安全的. 如果会话是安全的, 则不需要使用这个密钥序列机制.
</p><p>即使会话不安全, 本文前述章节定义的意外会话和请求IDs已经通过把连接绑定到一对持久TCP/IP连接的方法来提供了一个类似级别的保护，并且因此提供了防止'盲'绑定的足够保护. 无论如何, 在某些环境下, 以下定义的密钥序列机制帮助抵御了更多确定的和有知识的攻击者.
</p><p>重要的是要认识到以下定义的密钥序列机制只帮助我们保护抵御一个能在一个序列的不安全会话中看到所有请求或应答但不能修改那些请求的内容(在这种情况下, 这个机制阻止攻击者插入HTTP请求到会话, 例如, 终止请求或应答)的攻击者. 无论如何, 当攻击者能修改不安全的请求或应答的内容时，密钥序列机制不提供任何保护.
</p>
<h3> <span class="mw-headline" id=".E7.AE.80.E8.BF.B0">简述</span></h3>
<p>每个会话的HTTP请求可以通过一系列不同的socket连接来散播. 这将使得一个未经授权的收到该会话ID和会话请求ID的用户能够使用他们自己的socket连接来插入&lt;body/&gt;请求元素到会话中并接收相应的应答.
</p><p>以下的密钥序列机制通过允许连接管理器探查第三方插入的&lt;body/&gt;请求元素来抵御这类攻击.
</p>
<h3> <span class="mw-headline" id=".E7.94.9F.E6.88.90.E5.AF.86.E9.92.A5.E5.BA.8F.E5.88.97">生成密钥序列</span></h3>
<p>在请求一个新的会话之前, 客户端必须选择一个不可预知的计数器 ("n") 和一个不可预知的值 ("seed"). 然后客户端通过把这个"seed"做一次加密哈希运算并从160位转换成一个十六进制字符串 K(1). 它运算 "n" 次然后得到发起密钥 K(n). 这个哈希算法必须是 SHA-1 定义于 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc3174">RFC 3174</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">22</a> .
</p><p><b>示例19. 创建密钥序列</b>
</p>
<pre>       K(1) = hex(SHA-1(seed))
       K(2) = hex(SHA-1(K(1)))
       ...
       K(n) = hex(SHA-1(K(n-1)))
</pre>
<h3> <span class="mw-headline" id=".E4.BD.BF.E7.94.A8.E5.AF.86.E9.92.A5">使用密钥</span></h3>
<p>客户端必须把该会话中第一个请求的 'newkey' 属性值设为 K(n).
</p><p><b>示例20. 携带发起密钥的会话请求</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 104
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">content</span>=<span class="st0">'text/xml; charset=utf-8'</span>
      <span class="re0">hold</span>=<span class="st0">'1'</span>
      <span class="re0">rid</span>=<span class="st0">'1573741820'</span>
      <span class="re0">to</span>=<span class="st0">'example.com'</span>
      <span class="re0">wait</span>=<span class="st0">'60'</span>
      <span class="re0">xml:lang</span>=<span class="st0">'en'</span>
      <span class="re0">newkey</span>=<span class="st0">'ca393b51b682f61f98e7877d61146407f3d0a770'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>客户端必须把所有接下来的请求的 'key' 属性值设为按生成顺序的下一个密钥 (每个请求发送的值从 K(n-1) 向 K(1) 衰减).
</p><p><b>示例21. 携带密钥的请求</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 88
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1573741821'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">key</span>=<span class="st0">'bfb06a6f113cd6fd3838ab9d300fdb4fe3da2f7d'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>连接管理器可以通过运算密钥的 SHA-1 哈希并把它和前一个请求的 'newkey' 属性(或者如果没有'newkey' 属性则为 'key' 属性)进行比较来证实密钥. 如果这个值不匹配 (或者如果接收到一个不带 'key' 属性的请求，以及接收到的是前一个请求所设的 'newkey' 或 'key' 属性), 那么连接管理器必须不处理该元素, 必须终止该会话, 并且必须返回一个 'item-not-found' 终止绑定错误.
</p><p><b>示例22. 非法的密钥序列错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'item-not-found'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<h3> <span class="mw-headline" id=".E5.88.87.E6.8D.A2.E5.88.B0.E5.8F.A6.E4.B8.80.E4.B8.AA.E5.AF.86.E9.92.A5.E5.BA.8F.E5.88.97">切换到另一个密钥序列</span></h3>
<p>生成密钥序列的时候,客户端应该选择一个高的 "n" 值. 无论如何, 如果会话太长以至于客户端在序列 K(1) 中达到最后的密钥， 那么客户端必须切换到一个新的密钥序列.
</p><p>客户端必须:
</p>
<ol><li> 选择新的 "seed" 和 "n" 值.
</li><li> 使用上文定义的机制生成一个新的密钥序列.
</li><li> 把该请求的 'key' 属性设为旧的序列的下一个值 (也就是说 K(1), 最后的值).
</li><li> 把该请求的 'newkey' 属性设为新的序列的值 K(n).
</li></ol>
<p><b>示例23. 新密钥序列</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1573741822'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">key</span>=<span class="st0">'6f825e81f4532b2c5fa2d12457d8a1f22e8f838e'</span>
      <span class="re0">newkey</span>=<span class="st0">'113f58a37245ec9637266cf2fb6e48bfeaf7964e'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;message</span> <span class="re0">to</span>=<span class="st0">'contact@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">I said &quot;Hi!&quot;</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<h2> <span class="mw-headline" id=".E5.A4.9A.E9.87.8D.E6.B5.81">多重流</span></h2>
<h3> <span class="mw-headline" id=".E7.AE.80.E4.BB.8B_2">简介</span></h3>
<p>本章描述的可选特性允许在一个HTTP会话中包含多重XML流. 这个特性实质上用于那些不允许HTTP流水线的运行时环境中, 此时一个客户端能和每个连接管理器打开的并发HTTP请求的数量是受限的, 如果他们在同一时间使用不止一个帐号连接，那么运行于这类环境下的客户端需要多重流会话. 这个特性对于任何通过HTTP建立了并联流的客户端来说也降低了网络流量.
</p>
<h3> <span class="mw-headline" id=".E6.9F.A5.E8.AF.A2">查询</span></h3>
<p>如果一个连接管理器支持多重流特性, 它必须在它的会话创建应答中包含一个'stream'属性. 如果一个客户端不接受这个'stream'属性，那么它必须假定连接管理器不支持该特性. <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">23</a>
</p><p>这个 'stream' 属性标识该会话打开的第一个流. 每个 'stream' 属性的值必须是一个无意义的不可预知的名字，并且在连接管理器应用的上下文中是唯一的.
</p><p><b>示例24. 携带流名字(stream name)的会话创建应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 128
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">wait</span>=<span class="st0">'60'</span>
      <span class="re0">inactivity</span>=<span class="st0">'30'</span>
      <span class="re0">polling</span>=<span class="st0">'5'</span>
      <span class="re0">requests</span>=<span class="st0">'2'</span>
      <span class="re0">hold</span>=<span class="st0">'1'</span>
      <span class="re0">accept</span>=<span class="st0">'deflate,gzip'</span>
      <span class="re0">stream</span>=<span class="st0">'firstStreamName'</span>
      <span class="re0">maxpause</span>=<span class="st0">'120'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">charsets</span>=<span class="st0">'ISO_8859-1 ISO-2022-JP'</span>
      <span class="re0">ver</span>=<span class="st0">'1.6'</span>
      <span class="re0">from</span>=<span class="st0">'example.com'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<h3> <span class="mw-headline" id=".E6.B7.BB.E5.8A.A0.E6.B5.81.E5.88.B0.E4.BC.9A.E8.AF.9D">添加流到会话</span></h3>
<p>如果连接管理器在它的会话创建应答中包含了一个 'stream' 属性，那么客户端可以在任何时间发送一个空的带有'to'属性的&lt;body/&gt;元素来请求它打开另一个流. 请求必须包含合法的'sid'和'rid' <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">24</a> 属性, 并且也应该包含一个 'xml:lang' 属性. 请求可以包含 'route', 'from' 和 'secure' 属性 (见 <a href="/XEP-0124#.E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E8.AF.B7.E6.B1.82" title="XEP-0124">|会话创建请求</a> ), 但是它不应该包含 'ver', 'content', 'hold' 或 'wait' 属性 (因为并没有创建一个新的会话).
</p><p><b>示例25. 请求另一个流</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 104
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">rid</span>=<span class="st0">'1573741820'</span>
      <span class="re0">to</span>=<span class="st0">'example.com'</span>
      <span class="re0">route</span>=<span class="st0">'xmpp:example.com:9999'</span>
      <span class="re0">xml:lang</span>=<span class="st0">'en'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>如果连接管理器没有在会话的开始表示它支持多重流, 那么它必须忽略额外的属性并且和对待普通的用于载荷的空请求一样对待该请求(见 <a href="/XEP-0124#.E5.8F.91.E9.80.81.E5.92.8C.E6.8E.A5.E6.94.B6XM.E8.BD.BD.E8.8D.B7" title="XEP-0124">发送和接收XM载荷</a> ). <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">25</a> 否则它必须打开一个新的流到指定的服务器 (见 <a href="/XEP-0124#.E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E5.BA.94.E7.AD.94" title="XEP-0124">会话创建应答</a> ), 生成一个新的流名字, 并以此名字应答客户端. 应答也可以包含 'from' 和 'secure' 属性, 但是它不应该包含 'sid', 'requests', 'polling', 'hold', 'inactivity', 'maxpause', 'accept', 'charsets', 'ver' 或 'wait' 属性.
</p><p><b>示例26. 添加流应答</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 128
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">stream</span>=<span class="st0">'secondStreamName'</span>
      <span class="re0">from</span>=<span class="st0">'example.com'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>注意: 如果应答既不包含 'from' 也不包含 'secure' 属性，那么它们可以留待接下来的应答中被发送 (见 <a href="/XEP-0124#.E4.BC.9A.E8.AF.9D.E5.88.9B.E5.BB.BA.E5.BA.94.E7.AD.94" title="XEP-0124">会话创建应答</a> ). 在那种情况下 'stream' 属性也是必须指定的.
</p>
<h3> <span class="mw-headline" id=".E4.BC.A0.E9.80.81.E8.BD.BD.E8.8D.B7">传送载荷</span></h3>
<p>如果在一个会话中不止打开一个流, 那么被连接管理器发送的所有非空的&lt;body/&gt;元素必须包含'stream'属性，它定义所有的载荷属于哪个流. 客户端应该包含一个'stream'属性用于同样的目的. 如果客户端希望连接管理器广播这些载荷给所有打开的流，它可以忽略'stream'属性. 注意: 一个&lt;body/&gt;元素在不同的流中必须不能包含不同的载荷.
</p><p>如果一个流名字不符合该会话打开的流之一, 那么接收到的连接管理器应该返回一个 'item-not-found' 终止绑定错误, 或者接收到的客户端应该终止这个会话. 无论如何, 如果接收到的实体只是关闭这个流 (并且发送者可能在它发送这个载荷的时候没有留意), 那么它可以简单安静地忽略该&lt;body/&gt;元素包含的任何载荷.
</p><p>注意: 不包含'from'或'secure'属性的空的&lt;body/&gt;元素不应该包含'stream'属性(因为任何流都没有东西正在传送). 如果这样的一个&lt;body/&gt;元素包含了一个'stream'属性，那么接收到的实体应该忽略该属性.
</p><p><b>示例27. 客户端以一个流名字发送载荷</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243562'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">stream</span>=<span class="st0">'secondStreamName'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;message</span> <span class="re0">to</span>=<span class="st0">'contact@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">I said hello.</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<p>注意: 该应答的'stream'属性值可以和响应请求的不同. <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">26</a>
</p><p><b>示例28. 连接管理器应答一个不同的流名字</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 185
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">stream</span>=<span class="st0">'firstStreamName'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;message</span> <span class="re0">from</span>=<span class="st0">'contact@example.com'</span>
           <span class="re0">to</span>=<span class="st0">'user@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">Hi yourself!</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<p>如果连接管理器没有指定流名字，那么客户端必须假定载荷是和第一个流相关的(即使第一个流已经关闭了).
</p><p>如果客户端没有指定一个流名字，那么连接管理器必须广播载荷给所有打开的流. [27]
</p><p><b>示例29. 客户端请求一个载荷被广播</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 188
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243562'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;presence</span> <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;show<span class="re2">&gt;</span></span><span class="co3">away</span><span class="re1">&lt;/show<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/presence<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<h3> <span class="mw-headline" id=".E5.85.B3.E9.97.AD.E6.B5.81">关闭流</span></h3>
<p>如果在一个会话中打开了不止一个流, 客户端可以在任何时间使用上文 <a href="/XEP-0124#.E7.BB.88.E6.AD.A2HTTP.E4.BC.9A.E8.AF.9D" title="XEP-0124">终止HTTP会话</a> 描述的程序关闭一个流, 小心地在'stream'属性指定该流的名字. 如果客户端关闭了最后一个流，连接管理器必须终止该会话. 如果客户端没有指定一个流名字那么连接管理器必须关闭所有打开的流 (发送该终止请求的任何载荷到所有流), 并终止该会话.
</p><p><b>示例30. 客户端关闭一个流</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">POST /webclient HTTP/1.1
Host: httpcm.example.com
Accept-Encoding: gzip, deflate
Content-Type: text/xml; charset=utf-8
Content-Length: 153
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">rid</span>=<span class="st0">'1249243564'</span>
      <span class="re0">sid</span>=<span class="st0">'SomeSID'</span>
      <span class="re0">stream</span>=<span class="st0">'secondStreamName'</span>
      <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;presence</span> <span class="re0">type</span>=<span class="st0">'unavailable'</span>
            <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">/&gt;</span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<h3> <span class="mw-headline" id=".E9.94.99.E8.AF.AF.E6.9D.A1.E4.BB.B6">错误条件</span></h3>
<p>如果在一个会话中不止打开了一个流, 连接管理器可以在致命绑定错误中包含一个'stream'属性(见 <a href="/XEP-0124#.E7.BB.88.E6.AD.A2.E7.BB.91.E5.AE.9A.E6.9D.A1.E4.BB.B6" title="XEP-0124">终止绑定条件</a> ). 如果指定了'stream'属性，那么该流必须被双方实体关闭但是会话不应该被终止.
</p><p><b>示例31. 致命流错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'remote-connection-failed'</span>
      <span class="re0">stream</span>=<span class="st0">'secondStreamName'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>注意: 如果连接管理器在致命流错误中不包含'stream'属性，那么会话的所有的打开的流都必须被双方实体关闭并且会话必须被终止.
</p>
<h2> <span class="mw-headline" id=".E9.94.99.E8.AF.AF.E5.92.8C.E7.8A.B6.E6.80.81.E4.BB.A3.E7.A0.81">错误和状态代码</span></h2>
<p>在HTTP应答中有四种类型的错误和状态报告:
</p><p><b>表1: 错误条件类型</b>
</p>
<table border="1">
<tr>
<th>错误条件
</th>
<th>描述
</th></tr>
<tr>
<td>HTTP条件 (已过时)
</td>
<td>连接管理器应答从传统客户端来的非法请求一个HTTP错误. 这用于绑定语法错误, 可能的攻击, 等等. 注意受约束的客户端不能区分不同的HTTP错误.
</td></tr>
<tr>
<td>终止绑定条件
</td>
<td>这些错误条件可以被受约束的客户端读取. 他们用于连接管理器问题, 抽象流错误, 连接管理器和服务器之间的通讯问题, 以及非法客户端请求 (绑定语法错误, 可能的攻击, 等等.)
</td></tr>
<tr>
<td>可恢复的绑定条件
</td>
<td>这些报告连接管理器和客户端之间的通讯问题. 它们不终止会话. 客户端通过重新发送前面所有的未收到应答的&lt;body/&gt;封装器来从这些错误恢复.
</td></tr>
<tr>
<td>被传输的协议的条件
</td>
<td>和&lt;body/&gt;封装器中的XML载荷有关的错误, 通常定义于被传输的协议的文档中. 它们不终止会话.
</td></tr></table>
<p>完整的描述在下面.
</p>
<h3> <span class="mw-headline" id="HTTP.E6.9D.A1.E4.BB.B6">HTTP条件</span></h3>
<p>注意: 除了200所有HTTP代码已经被终止绑定条件取代，以使客户端能确定错误的来源是连接管理器应用还是HTTP媒介.
</p><p>传统的客户端(或连接管理器)在它的会话创建请求(或应答)中是不包含'ver'属性的. 传统客户端(或连接管理器)将根据下表来解释(或应答) HTTP错误码. 非传统连接管理器应该不发送HTTP错误码，除非它们连接的是一个传统客户端. 在接收到一个HTTP错误(400, 403, 404)之后, 一个传统客户端或任何连接到传统连接管理器的客户端必须认为该会话为空的和无用的(null and void). 一个连接到非传统连接管理器的非传统客户端可以认为该会话仍活跃.
</p><p><b>表2: HTTP错误和状态码</b>
</p>
<table border="1">
<tr>
<th>代码
</th>
<th>名称
</th>
<th>被...取代
</th>
<th>目的
</th></tr>
<tr>
<td>200
</td>
<td>OK
</td>
<td>-
</td>
<td>应答给合法的客户端请求.
</td></tr>
<tr>
<td>400
</td>
<td>Bad Request
</td>
<td>bad-request
</td>
<td>通知客户端一个HTTP头的格式或绑定的元素是不可接受的(例如, 语法错误).
</td></tr>
<tr>
<td>403
</td>
<td>Forbidden
</td>
<td>policy-violation
</td>
<td>通知客户端它违反了会话规则(轮询太频繁, 请求太频繁, 太多并发请求).
</td></tr>
<tr>
<td>404
</td>
<td>Not Found
</td>
<td>item-not-found
</td>
<td>通知客户端 (1) 'sid' 不合法, (2) 'stream' 不合法, (3) 'rid' 大于期望的窗口上限, (4) 连接管理器不能重发应答, (5) 'key' 顺序不合法.
</td></tr></table>
<p>注意: 没有其他定义在早期版本BOSH里的HTTP错误和状态码 (例如, Internal Server Error).
</p>
<h3> <span class="mw-headline" id=".E7.BB.88.E6.AD.A2.E7.BB.91.E5.AE.9A.E6.9D.A1.E4.BB.B6">终止绑定条件</span></h3>
<p>在任何发送到客户端的应答里, 连接管理器可以通过把&lt;body/&gt;元素的'type'属性值设为"terminate"来返回一个致命错误. 这些绑定错误标识该HTTP会话被终止了(除非定义了一个'stream'属性 -- 见 <a href="/XEP-0124#.E9.94.99.E8.AF.AF.E6.9D.A1.E4.BB.B6" title="XEP-0124">多重流错误条件</a> ).
</p><p>注意: 尽管这些条件中的一部分类似定义于 <b><a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc6120">RFC 6120</a></b> 的XMPP流错误条件, 它们不会被XMPP流错误混淆. 在这里BOSH是用于传输XMPP, 在连接管理器和XMPP服务器之间经历的任何致命XMPP流错误条件只会被用下面描述的"remote-stream-error"条件来报告.
</p><p><b>示例32. 远程连接失败错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">condition</span>=<span class="st0">'remote-connection-failed'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<p>'condition'属性的值定义如下:
</p><p><b>表3: 终止绑定错误条件</b>
</p>
<table border="1">
<tr>
<th>条件
</th>
<th>目的
</th></tr>
<tr>
<td>bad-request*
</td>
<td>T一个HTTP头或从客户端收到的绑定元素的格式不可接受(例如, 语法错误).
</td></tr>
<tr>
<td>host-gone
</td>
<td>连接管理器的'to'属性指定的目标域或'route'属性指定的目标主机或端口不再提供服务.
</td></tr>
<tr>
<td>host-unknown
</td>
<td>连接管理器的'to'属性指定的目标域或'route'属性指定的目标主机或端口是未知的.
</td></tr>
<tr>
<td>improper-addressing
</td>
<td>发起元素缺少'to'或'route'属性(或属性没有值)但是连接管理器需要它.
</td></tr>
<tr>
<td>internal-server-error
</td>
<td>连接管理器经历了一个内部错误导致它无法为请求提供服务.
</td></tr>
<tr>
<td>item-not-found*
</td>
<td>(1) 'sid'不合法, (2) 'stream'不合法, (3) 'rid' 大于期望窗口的上限, (4) 连接管理器不能重发应答, (5) 'key' 序列非法.
</td></tr>
<tr>
<td>other-request
</td>
<td>和这个请求请求想同的另一个请求导致该会话终止.
</td></tr>
<tr>
<td>policy-violation*
</td>
<td>客户端违反了会话规则(轮询太频繁, 请求太频繁, 发送了过多的并发请求).
</td></tr>
<tr>
<td>remote-connection-failed
</td>
<td>连接管理器无法连接, 或无法安全地连接, 或已经丢失了它的连接, 到服务器.
</td></tr>
<tr>
<td>remote-stream-error
</td>
<td>封装了一个正在传输的协议的错误.
</td></tr>
<tr>
<td>see-other-uri
</td>
<td>连接管理器不执行这个URI(例如, 连接管理器只接受客户端以类似 https: URI 而不是类似 the http: URI 的请求以SSL或TLS连接). 客户端可以尝试 POSTing 到&lt;uri/&gt;子元素内含的那个 URI .
</td></tr>
<tr>
<td>system-shutdown
</td>
<td>连接管理器正在关闭. 所有激活的HTTP会话正在被终止. 不能创建新的会话.
</td></tr>
<tr>
<td>undefined-condition
</td>
<td>这个错误不是在这里定义的那些错误之一; 连接管理器应该在这个&lt;body/&gt;封装器的内容里包含 应用特有的 信息.
</td></tr></table>
<p>* 如果客户端在它的会话创建请求中未包含一个'ver'属性，那么连接管理器应该发送一个已过时的HTTP错误而不是这个终止绑定错误条件. 如果连接管理器在它的会话创建应答中未包含'ver'属性，那么客户端应该预期它会发送一个已过时的HTTP错误条件而不是这个终止会话绑定条件.

</p><p>以下是一个 "see-other-uri" 条件的例子:
</p><p><b>示例33. 参见另一个URI错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">condition</span>=<span class="st0">'see-other-uri'</span>
      <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;uri<span class="re2">&gt;</span></span><span class="co3">https://secure.jabber.org/xmppcm</span><span class="re1">&lt;/uri<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<p>以下是一个包含"remote-stream-error"条件的例子:
</p><p><b>示例34. 远程错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">condition</span>=<span class="st0">'remote-stream-error'</span>
      <span class="re0">type</span>=<span class="st0">'terminate'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span>
      <span class="re0">xmlns:stream</span>=<span class="st0">'http://etherx.jabber.org/streams'</span><span class="re2">&gt;</span>
  <span class="re1">&lt;message</span> <span class="re0">from</span>=<span class="st0">'contact@example.com'</span>
           <span class="re0">to</span>=<span class="st0">'user@example.com'</span>
           <span class="re0">xmlns</span>=<span class="st0">'jabber:client'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;body<span class="re2">&gt;</span></span><span class="co3">I said &quot;Hi!&quot;</span><span class="re1">&lt;/body<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/message<span class="re2">&gt;</span></span>
  <span class="re1">&lt;stream:error<span class="re2">&gt;</span></span>
    <span class="re1">&lt;xml-not-well-formed</span> <span class="re0">xmlns</span>=<span class="st0">'urn:ietf:params:xml:ns:xmpp-streams'</span><span class="re2">/&gt;</span>
    <span class="re1">&lt;text</span> <span class="re0">xmlns</span>=<span class="st0">'urn:ietf:params:xml:ns:xmpp-streams'</span>
          <span class="re0">xml:lang</span>=<span class="st0">'en'</span><span class="re2">&gt;</span><span class="co3">
      Some special application diagnostic information!
    </span><span class="re1">&lt;/text<span class="re2">&gt;</span></span>
    <span class="re1">&lt;escape-your-data</span> <span class="re0">xmlns</span>=<span class="st0">'application-ns'</span><span class="re2">/&gt;</span>
  <span class="re1">&lt;/stream:error<span class="re2">&gt;</span></span>
<span class="re1">&lt;/body<span class="re2">&gt;</span></span></pre></div></div>
<p>自然的, 客户端同样可以报告绑定错误给连接管理器, 尽管这是这是不太可能的.
</p>
<h3> <span class="mw-headline" id=".E5.8F.AF.E6.81.A2.E5.A4.8D.E7.9A.84.E7.BB.91.E5.AE.9A.E6.9D.A1.E4.BB.B6">可恢复的绑定条件</span></h3>
<p>在任何连接管理器发送给客户端的应答中, 它可以通过设置&lt;body/&gt;元素的'type'属性为"error"来返回一个可恢复的错误. 这些错误不表示HTTP会话被终止.
</p><p>如果客户端决定从这个错误回复, 那么它必须重复那个发生错误的HTTP请求, 以及所有前面没有收到应答的HTTP请求. 这些请求的内容必须和原始请求的&lt;body/&gt;元素相同. 这使连接管理器在前一个请求因为通讯失败而丢失之后能恢复一个会话.
</p><p><b>示例35. 可恢复的错误</b>
</p>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="co3">HTTP/1.1 200 OK
Content-Type: text/xml; charset=utf-8
Content-Length: 68
&#160;
</span><span class="re1">&lt;body</span> <span class="re0">type</span>=<span class="st0">'error'</span>
      <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span><span class="re2">/&gt;</span></pre></div></div>
<h3> <span class="mw-headline" id="XML.E8.BD.BD.E8.8D.B7.E6.9D.A1.E4.BB.B6">XML载荷条件</span></h3>
<p>应用级的错误条件描述请参看正在被传输并通过连接管理器路由到客户端的那个协议的文档. 它们对连接管理器来说是透明的, 所以超过了这里定义的传输绑定的范围.
</p>
<h2> <span class="mw-headline" id=".E5.AE.9E.E7.8E.B0.E5.A4.87.E6.B3.A8">实现备注</span></h2>
<h3> <span class="mw-headline" id="HTTP.E6.B5.81.E6.B0.B4.E7.BA.BF">HTTP流水线</span></h3>
<p>即使客户端请求HTTP流水线并且连接管理器支持它, 也不保证流水线能成功, 因为它可能不被中间代理支持.
</p><p>客户端能做到最好的是通过设置'hold'属性的值为"1"来请求使用HTTP流水线. 如果HTTP流水线没生效(因为服务器返回 HTTP 1.0 或 connection:close), 那么客户端应该降格为使用多重连接.
</p>
<h2> <span class="mw-headline" id=".E5.AE.89.E5.85.A8.E4.BA.8B.E9.A1.B9">安全事项</span></h2>
<h3> <span class="mw-headline" id=".E5.9C.A8.E5.AE.A2.E6.88.B7.E7.AB.AF.E5.92.8CBOSH.E6.9C.8D.E5.8A.A1.E4.B9.8B.E9.97.B4.E8.BF.9E.E6.8E.A5">在客户端和BOSH服务之间连接</span></h3>
<p>客户端和BOSH服务之间的所有通讯应该发生在加密的HTTP连接之上. 客户端和连接管理器之间的加密应该发生在传输层或HTTP层, 而不是应用层; 这个协商应该遵循定义于 <a rel="nofollow" class="external text" href="http://wp.netscape.com/eng/ssl3/draft302.txt">SSL</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">28</a> 的 HTTP/SSL 协议, 当然也可以遵循定义于 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc2818">RFC 2818</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">29</a> 的 HTTP/TLS 协议或定义于 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc2817">RFC 2817</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">30</a> 的基于HTTP协议的TLS.
</p><p>如果用来发送发起会话请求的HTTP连接是加密的, 那么该会话中使用的所有其他HTTP连接也必须是加密的. 此外, 如果当建立用来发送发起会话请求的加密连接的时候交换了验证证书, 那么客户端 和/或 连接管理器应该确保在该会话接下来的所有连接中使用同一个验证证书. 一旦这样一个 "安全会话" 被建立:
</p>
<ul><li> 如果连接管理器拒绝简历一个加密连接或提供了不同的证书, 那么客户端应该关闭连接并终止会话而不发送任何更多的请求.
</li><li> 如果客户端通过一个未加密的连接或使用了一个不同的证书发送了属于某个"安全会话"一部分的封装元素, 那么连接管理器应该简单地关闭该连接. 连接管理应该不终止该会话，因为那将使拒绝服务攻击更容易.
</li></ul>
<h3> <span class="mw-headline" id="BOSH.E5.92.8C.E5.BA.94.E7.94.A8.E4.B9.8B.E9.97.B4.E7.9A.84.E8.BF.9E.E6.8E.A5">BOSH和应用之间的连接</span></h3>
<p>一个BOSH服务应该使用适当的技术例如安全套接字层(SSL),传输层安全(TLS)以及StartTLS(如果后台程序支持的话) 等等来加密它到后台应用的连接. 另外, BOSH 服务在以下情形中可以被认为安全 (1) 如果它运行在和后台应用同一个物理机上 或 (2) 如果它运行在和后台应用同一个私有网络上并且管理员确信未知的个人或程序不能访问私有网络.
</p><p>如果数据隐私是必需的, 客户端应该使用一个应用级别的点对点加密技术来加密它的消息, 因为客户端没办法确信BOSH服务加密了它到该应用的连接; 这些方法超出了本协议的范围.
</p>
<h3> <span class="mw-headline" id=".E4.B8.8D.E5.8F.AF.E9.A2.84.E6.B5.8B.E7.9A.84SID.E5.92.8CRID">不可预测的SID和RID</span></h3>
<p>会话标识符(SID)和发起请求标识符(RID)是安全的关键所以都必须是不可预测的和不重复的(见 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc1750">RFC 1750</a> <a href="/index.php?title=XEP-01243%E9%99%84%E5%BD%95G:%E5%A4%87%E6%B3%A8&amp;action=edit&amp;redlink=1" class="new" title="XEP-01243附录G:备注（尚未撰写）">31</a> 的关于为了安全目的对SIDs和发起RIDs的随机性的建议).
</p>
<h3> <span class="mw-headline" id=".E4.BD.BF.E7.94.A8SHA-1">使用SHA-1</span></h3>
<p>最近的研究显示，在选定的情况下，使用SHA-1哈希算法来产生哈希值是最有可能的(见 <a rel="nofollow" class="external text" href="http://tools.ietf.org/html/rfc4270">RFC 4270</a> <a href="/XEP-0124#G:.E5.A4.87.E6.B3.A8" title="XEP-0124">32</a> ). 无论如何, 在BOSh中使用SHA-1看起来会最小化该文献描述的可能的攻击. 另外, 目前的评估表明，在经常发现的攻击中, 它将耗费政府级实体的运算能力一年才可能出现问题.
</p>
<h2> <span class="mw-headline" id="IANA.E4.BA.8B.E9.A1.B9">IANA事项</span></h2>
<p>TCP端口5280, 传统上用于BOSH客户端和BOSH连接管理器的通讯, 已经注册到 <a rel="nofollow" class="external text" href="http://www.iana.org/">互联网编号分配机构(IANA)</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">33</a> 在它的 <a rel="nofollow" class="external text" href="http://www.iana.org/assignments/port-numbers">IANA端口号码注册表</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">34</a> 的端口注册表里 , 关键词为 "xmpp-bosh". (尽管这个端口的使用是可选的, 定义这个端口有助于标准化，这样BOSH客户端可以通过BOSH联系任何一个给定的XMPP服务而不需要 <a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0156.html">查找替代的XMPP连接方法</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">35</a> 描述的 DNS TXT 记录或更多先进的方法例如 U-NAPTR.
</p>
<h2> <span class="mw-headline" id="XMPP.E6.B3.A8.E5.86.8C.E4.BA.8B.E9.A1.B9">XMPP注册事项</span></h2>
<h3> <span class="mw-headline" id=".E5.8D.8F.E8.AE.AE.E5.91.BD.E5.90.8D.E7.A9.BA.E9.97.B4">协议命名空间</span></h3>
<p>在它的协议命名空间注册项中包含了 '<a rel="nofollow" class="external free" href="http://jabber.org/protocol/httpbind'">http://jabber.org/protocol/httpbind'</a> 的XMPP注册项.
</p>
<h2> <span class="mw-headline" id="XML_Schema">XML Schema</span></h2>
<div dir="ltr" style="text-align: left;"><div class="source-xml" style="font-family: monospace;"><pre><span class="re1">&lt;?xml</span> <span class="re0">version</span>=<span class="st0">'1.0'</span> <span class="re0">encoding</span>=<span class="st0">'UTF-8'</span><span class="re2">?&gt;</span>
&#160;
<span class="re1">&lt;xs:schema</span>
    <span class="re0">xmlns:xs</span>=<span class="st0">'http://www.w3.org/2001/XMLSchema'</span>
    <span class="re0">xmlns:stream</span>=<span class="st0">'http://etherx.jabber.org/streams'</span>
    <span class="re0">targetNamespace</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span>
    <span class="re0">xmlns</span>=<span class="st0">'http://jabber.org/protocol/httpbind'</span>
    <span class="re0">elementFormDefault</span>=<span class="st0">'qualified'</span><span class="re2">&gt;</span>
&#160;
  <span class="re1">&lt;xs:annotation<span class="re2">&gt;</span></span>
    <span class="re1">&lt;xs:documentation<span class="re2">&gt;</span></span><span class="co3">
      The protocol documented by this schema is defined in
      XEP-0124: http://www.xmpp.org/extensions/xep-0124.html
    </span><span class="re1">&lt;/xs:documentation<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/xs:annotation<span class="re2">&gt;</span></span>
&#160;
  <span class="re1">&lt;xs:import</span> <span class="re0">namespace</span>=<span class="st0">'http://www.w3.org/XML/1998/namespace'</span>
             <span class="re0">schemaLocation</span>=<span class="st0">'http://www.w3.org/2001/03/xml.xsd'</span><span class="re2">/&gt;</span>
&#160;
  <span class="re1">&lt;xs:element</span> <span class="re0">name</span>=<span class="st0">'body'</span><span class="re2">&gt;</span>
    <span class="re1">&lt;xs:complexType<span class="re2">&gt;</span></span>
      <span class="re1">&lt;xs:choice<span class="re2">&gt;</span></span>
        <span class="re1">&lt;xs:element</span> <span class="re0">name</span>=<span class="st0">'uri'</span>
                <span class="re0">minOccurs</span>=<span class="st0">'0'</span>
                <span class="re0">maxOccurs</span>=<span class="st0">'1'</span>
                <span class="re0">type</span>=<span class="st0">'xs:string'</span><span class="re2">/&gt;</span>
        <span class="re1">&lt;xs:any</span> <span class="re0">namespace</span>=<span class="st0">'##other'</span>
                <span class="re0">minOccurs</span>=<span class="st0">'0'</span>
                <span class="re0">maxOccurs</span>=<span class="st0">'unbounded'</span>
                <span class="re0">processContents</span>=<span class="st0">'lax'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;/xs:choice<span class="re2">&gt;</span></span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'accept'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'ack'</span> <span class="re0">type</span>=<span class="st0">'xs:positiveInteger'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'authid'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'charsets'</span> <span class="re0">type</span>=<span class="st0">'xs:NMTOKENS'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'condition'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">&gt;</span>
        <span class="re1">&lt;xs:simpleType<span class="re2">&gt;</span></span>
          <span class="re1">&lt;xs:restriction</span> <span class="re0">base</span>=<span class="st0">'xs:NCName'</span><span class="re2">&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'bad-request'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'host-gone'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'host-unknown'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'improper-addressing'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'internal-server-error'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'item-not-found'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'other-request'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'policy-violation'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'remote-connection-failed'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'remote-stream-error'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'see-other-uri'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'system-shutdown'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'undefined-condition'</span><span class="re2">/&gt;</span>
          <span class="re1">&lt;/xs:restriction<span class="re2">&gt;</span></span>
        <span class="re1">&lt;/xs:simpleType<span class="re2">&gt;</span></span>
      <span class="re1">&lt;/xs:attribute<span class="re2">&gt;</span></span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'content'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'from'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'hold'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedByte'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'inactivity'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedShort'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'key'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'maxpause'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedShort'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'newkey'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'pause'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedShort'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'polling'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedShort'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'report'</span> <span class="re0">type</span>=<span class="st0">'xs:positiveInteger'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'requests'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedByte'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'rid'</span> <span class="re0">type</span>=<span class="st0">'xs:positiveInteger'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'route'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'sid'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'stream'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'time'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedShort'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'to'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'type'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">&gt;</span>
        <span class="re1">&lt;xs:simpleType<span class="re2">&gt;</span></span>
          <span class="re1">&lt;xs:restriction</span> <span class="re0">base</span>=<span class="st0">'xs:NCName'</span><span class="re2">&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'error'</span><span class="re2">/&gt;</span>
            <span class="re1">&lt;xs:enumeration</span> <span class="re0">value</span>=<span class="st0">'terminate'</span><span class="re2">/&gt;</span>
          <span class="re1">&lt;/xs:restriction<span class="re2">&gt;</span></span>
        <span class="re1">&lt;/xs:simpleType<span class="re2">&gt;</span></span>
      <span class="re1">&lt;/xs:attribute<span class="re2">&gt;</span></span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'ver'</span> <span class="re0">type</span>=<span class="st0">'xs:string'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">name</span>=<span class="st0">'wait'</span> <span class="re0">type</span>=<span class="st0">'xs:unsignedShort'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:attribute</span> <span class="re0">ref</span>=<span class="st0">'xml:lang'</span> <span class="re0">use</span>=<span class="st0">'optional'</span><span class="re2">/&gt;</span>
      <span class="re1">&lt;xs:anyAttribute</span> <span class="re0">namespace</span>=<span class="st0">'##other'</span> <span class="re0">processContents</span>=<span class="st0">'lax'</span><span class="re2">/&gt;</span>
    <span class="re1">&lt;/xs:complexType<span class="re2">&gt;</span></span>
  <span class="re1">&lt;/xs:element<span class="re2">&gt;</span></span>
&#160;
<span class="re1">&lt;/xs:schema<span class="re2">&gt;</span></span></pre></div></div>
<h2> <span class="mw-headline" id=".E8.87.B4.E8.B0.A2">致谢</span></h2>
<p>感谢 Mike Cumings, Tomas Karasek, Tobias Markmann, Chris Seymour, Safa Sofuoğlu, Stefan Strigler, Matthew Wild, Kevin Winters, 以及 Christopher Zorn 的反馈.
</p>
<h2> <span class="mw-headline" id=".E9.99.84.E5.BD.95">附录</span></h2>
<h3> <span class="mw-headline" id=".E9.99.84.E5.BD.95A:.E6.96.87.E6.A1.A3.E4.BF.A1.E6.81.AF">附录A:文档信息</span></h3>
<p>系列：<a rel="nofollow" class="external text" href="http://xmpp.org/extensions/">XEP</a>
</p><p>序号：0124
</p><p>发布者：<a rel="nofollow" class="external text" href="http://xmpp.org/xsf/">XMPP标准基金会</a>
</p><p>状态：<a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0001.html#states-Draft">草案</a>
</p><p>类型：<a rel="nofollow" class="external text" href="http://www.xmpp.org/extensions/xep-0001.html#types-Standards%20Track">标准跟踪</a>
</p><p>版本：1.10
</p><p>最后更新时间：2010-07-02
</p><p>批准机构：<a rel="nofollow" class="external text" href="http://xmpp.org/council/">XMPP理事会</a>
</p><p>依赖标准：<a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc1945">RFC 1945</a>, <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2616">RFC 2616</a>, <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc3174">RFC 3174</a>
</p><p>替代标准：无
</p><p>被替代标准：无
</p><p>缩略名：bosh
</p><p>Schema: &lt;<a rel="nofollow" class="external free" href="http://www.xmpp.org/schemas/httpbind.xsd">http://www.xmpp.org/schemas/httpbind.xsd</a>&gt;
</p><p>原文控制： <a rel="nofollow" class="external text" href="http://gitorious.org/xmpp/xmpp/blobs/master/extensions/xep-0124.xml">HTML</a>
</p><p>本文的其它格式： <a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0124.xml">XML</a> <a rel="nofollow" class="external text" href="http://xmpp.org/extensions/xep-0124.pdf">PDF</a>
</p>
<h3> <span class="mw-headline" id="Appendix_B:_Author_Information">Appendix B: Author Information</span></h3>
<p><b>Ian Paterson</b>
</p>
<dl><dd>Email: <a rel="nofollow" class="external text" href="mailto:ian.paterson@clientside.co.uk">ian.paterson@clientside.co.uk</a>
</dd><dd>JabberID: ian@zoofy.com
</dd></dl>
<p><b>Dave Smith</b>
</p>
<dl><dd>Email: <a rel="nofollow" class="external text" href="mailto:dizzyd@jabber.org">dizzyd@jabber.org</a>
</dd><dd>JabberID: dizzyd@jabber.org
</dd></dl>
<p><b>Peter Saint-Andre</b>
</p>
<dl><dd>Email: <a rel="nofollow" class="external text" href="mailto:stpeter@jabber.org">stpeter@jabber.org</a>
</dd><dd>JabberID: stpeter@jabber.org
</dd><dd>URI: <a rel="nofollow" class="external free" href="https://stpeter.im/">https://stpeter.im/</a>
</dd></dl>
<p><b>Jack Moffitt</b>
</p>
<dl><dd>Email: <a rel="nofollow" class="external text" href="mailto:jack@chesspark.com">jack@chesspark.com</a>
</dd><dd>JabberID: jack@chesspark.com
</dd></dl>
<h3> <span class="mw-headline" id=".E9.99.84.E5.BD.95C:.E6.B3.95.E5.BE.8B.E9.80.9A.E5.91.8A">附录C:法律通告</span></h3>
<ul><li>版权
</li></ul>
<dl><dd>XMPP扩展协议的版权(1999 - 2011)归XMPP标准化基金会(XSF)所有.
</dd></dl>
<ul><li>权限
</li></ul>
<dl><dd>特此授权,费用全免,对任何获得本协议副本的人,对使用本协议没有限制,包括不限制在软件程序中实现本协议,不限制在网络服务中布署本协议,不限制拷贝,修改,合并,发行,翻译,分发,转授,或销售本协议的副本,被允许使用本协议做了以上工作的人士,应接受前述的版权声明和本许可通知并且必须包含在所有的副本或实质性部分的规格中.除非单独的许可，被重新分发的修改工作，不得含有关于作者，标题，编号，或出版者的规格的误导性资料，并不得宣称修改工作是由本文的作者，作者所属的任何组织或项目，或XMPP标准基金会签注。
</dd></dl>
<ul><li>免责声明
</li></ul>
<dl><dd><b>##特别注意：本协议是提供的“原样”的基础，没有担保或任何形式的条件，明示或暗示，包括，但不限于任何担保或关于名称，非侵权性，适销性或适合作某一特定目的的条件. ##</b>
</dd></dl>
<ul><li>责任限制
</li></ul>
<dl><dd>在任何情况下以及没有任何法律规定时，不论是侵权行为（包括疏忽），合同或其它方面，除非根据适用法律的要求（如蓄意和有严重疏忽行为）或以书面形式同意，XMPP标准基金会或任何作者不对本协议所造成的损失承担责任，包括任何直接，间接，特殊，偶发，或任何从本协议出，入，连接的字符产生的或实现，布署或其他对本协议的使用导致的相应的损害赔偿（包括但不限于善意的损失，停止作业，电脑失灵或故障，或任何和所有其他商业损害或损失） ，即使XMPP标准基金会或作者已被告知此类损害的可能性。
</dd></dl>
<ul><li>知识产权的一致性
</li></ul>
<dl><dd>XMPP扩展协议完全遵守XSF的知识产权策略(可在&lt;<a rel="nofollow" class="external free" href="http://www.xmpp.org/extensions/ipr-policy.shtml">http://www.xmpp.org/extensions/ipr-policy.shtml</a>&gt;找到副本或写信给XMPP标准基金会, 1899 Wynkoop Street, Suite 600, Denver, CO 80202 USA).
</dd></dl>
<h3> <span class="mw-headline" id=".E9.99.84.E5.BD.95D:.E5.92.8CXMPP.E7.9A.84.E5.85.B3.E7.B3.BB">附录D:和XMPP的关系</span></h3>
<p>可扩展的消息和出席信息协议 (XMPP) 定义于 XMPP Core (<a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc3920">RFC 3920</a>) 和 XMPP IM (<a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc3921">RFC 3921</a>) 规范里，由 XMPP标准基金会贡献到由依据<a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2026">RFC 2026</a>成立的互联网工程人物组管理的互联网标准流程 Internet Standards Process. 本文定义的任何协议已在互联网标准流程之外开发，并且被理解为 XMPP 的扩展而不是一个XMPP本身的演化, 开发, 或修改.
</p>
<h3> <span class="mw-headline" id=".E9.99.84.E5.BD.95E:.E8.AE.A8.E8.AE.BA.E5.9C.B0.E7.82.B9">附录E:讨论地点</span></h3>
<p>主要的XMPP扩展协议讨论地点是 &lt;standards@xmpp.org&gt; 讨论列表.
</p><p>在 xmpp.org 的其它讨论列表中的讨论可能也有合适的; 所有的列表见 &lt;<a rel="nofollow" class="external free" href="http://xmpp.org/about/discuss.shtml">http://xmpp.org/about/discuss.shtml</a>&gt; .
</p><p>Given that this XMPP Extension Protocol normatively references IETF technologies, discussion on the &lt;xsf-ietf@xmpp.org&gt; list might also be appropriate.
</p><p>勘误表可以发送邮件到 &lt;editor@xmpp.org&gt;.
</p>
<h3> <span class="mw-headline" id=".E9.99.84.E5.BD.95F:.E9.9C.80.E6.B1.82.E4.B8.80.E8.87.B4.E6.80.A7">附录F:需求一致性</span></h3>
<p>以下用于本文的需求关键字的解释见于 <a rel="nofollow" class="external text" href="http://www.ietf.org/rfc/rfc2119.txt">RFC 2119</a>: "MUST", "SHALL", "REQUIRED"; "MUST NOT", "SHALL NOT"; "SHOULD", "RECOMMENDED"; "SHOULD NOT", "NOT RECOMMENDED"; "MAY", "OPTIONAL".
</p>
<h3> <span class="mw-headline" id=".E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8">附录G:备注</span></h3>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc793">RFC 793</a>: 传输控制协议 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc0793">http://tools.ietf.org/html/rfc0793</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc1945">RFC 1945</a>: 超文本传输协议 -- HTTP/1.0 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc1945">http://tools.ietf.org/html/rfc1945</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2616">RFC 2616</a>: 超文本传输协议 -- HTTP/1.1 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc2616">http://tools.ietf.org/html/rfc2616</a>&gt;.
</li></ol>
<ol><li> Bayeux协议 &lt;<a rel="nofollow" class="external free" href="http://svn.cometd.org/trunk/bayeux/bayeux.html">http://svn.cometd.org/trunk/bayeux/bayeux.html</a>&gt;.
</li></ol>
<ol><li> Web套接字协议 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol">http://tools.ietf.org/html/draft-hixie-thewebsocketprotocol</a>&gt;.
</li></ol>
<ol><li> 反向HTTP &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/draft-lentczner-rhttp">http://tools.ietf.org/html/draft-lentczner-rhttp</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2965">RFC 2965</a>: HTTP状态管理机制 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc2965">http://tools.ietf.org/html/rfc2965</a>&gt;.
</li></ol>
<ol><li> 要求cookies是次优的，因为很多重要的计算平台只提供底层HTTP请求/应答的有限访问; 更坏的是, 一些平台或者移除了cookie相关的头.
</li></ol>
<ol><li> XEP-0025: Jabber HTTP轮询 &lt;<a rel="nofollow" class="external free" href="http://xmpp.org/extensions/xep-0025.html">http://xmpp.org/extensions/xep-0025.html</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc6120">RFC 6120</a>: 可扩展的消息和出席信息协议 (XMPP): 核心 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc6120">http://tools.ietf.org/html/rfc6120</a>&gt;.
</li></ol>
<ol><li> XEP-0206: 在BOSH上的XMPP  &lt;<a rel="nofollow" class="external free" href="http://xmpp.org/extensions/xep-0206.html">http://xmpp.org/extensions/xep-0206.html</a>&gt;.
</li></ol>
<ol><li> 为了减少网络拥塞, <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2616">RFC 2616</a> 建议客户端在同一时间不应该和同一台HTTP服务器保持超过两个HTTP连接. 运行在受约束的环境的客户端通常没有机会选择而只能遵守该建议.
</li></ol>
<ol><li> 如果没有"pings"之外的流量，那么带宽拥塞将是单个TCP连接的两倍(尽管加倍空仍然是空). 如果被发送的数据是一些大的包，那么带宽拥塞情况也是几乎一致的.
</li></ol>
<ol><li> 可扩展标记语言 (XML) 1.0 (第四版) &lt;<a rel="nofollow" class="external free" href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>&gt;.
</li></ol>
<ol><li> XML的名字空间  &lt;<a rel="nofollow" class="external free" href="http://www.w3.org/TR/REC-xml-names/">http://www.w3.org/TR/REC-xml-names/</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc4627">RFC 4627</a>: 用于JavaScript对象符号(JSON) 的 应用程序/json 媒体类型  &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc4627">http://tools.ietf.org/html/rfc4627</a>&gt;.
</li></ol>
<ol><li> 可扩展的标记语言 (XML) 1.0 (第四版) &lt;<a rel="nofollow" class="external free" href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>&gt;.
</li></ol>
<ol><li> 尽管'route'属性的语法粗看起来和一个URI或IRI相似, 它不是一个 URI/IRI 并且不可按照 <b><a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc3986">RFC 3986</a>, <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc3987">RFC 3987</a>, 或 (用于XMPP) <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc5122">RFC 5122</a></b> 定义的规则来处理.
</li></ol>
<ol><li> 每个字符集名称(或字符编码名称 -- 我们使用互换的条款) 应该是类型 NMTOKEN, 这里名称是由空格符号 #x20 分隔的, 造成一个标记话的属性类型 NMTOKENS (见 <a rel="nofollow" class="external text" href="http://www.w3.org/TR/REC-xml/">XML 1.0</a> <a href="/XEP-0124#.E9.99.84.E5.BD.95G:.E5.A4.87.E6.B3.A8" title="XEP-0124">20</a> 的 3.3.1 章节). 严格地说, 由互联网编号分配机构(见 &lt;<a rel="nofollow" class="external free" href="http://www.iana.org/assignments/character-sets">http://www.iana.org/assignments/character-sets</a>&gt;)维护的字符集注册项允许一个字符集名称包含任何可打印的US-ASCII字符串, 它可能包含不被 XML 1.0的NMTOKEN构造所允许的字符串; 无论如何, 仅存的一个字符集名称包含这样的字符串的字符集是 "NF_Z_62-010_(1973)".
</li></ol>
<ol><li> 可扩展的标记语言 (XML) 1.0 (第四版) &lt;<a rel="nofollow" class="external free" href="http://www.w3.org/TR/REC-xml/">http://www.w3.org/TR/REC-xml/</a>&gt;.
</li></ol>
<ol><li> 9007199254740991 等于 2的53次方-1. 一些弱类型的语言使用IEEE标准754 Doubles来表达所有数字. 这些 Doubles 不能准确表达所有超过 2的53次方的整数.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc3174">RFC 3174</a>: 使用安全哈希算法1 (SHA1) &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc3174">http://tools.ietf.org/html/rfc3174</a>&gt;.
</li></ol>
<ol><li> 因此客户端和连接管理器将兼容，即使其中一个不提供对多流会话的支持.
</li></ol>
<ol><li> 'rid'属性总是正常增加而不参考任何'stream'属性.
</li></ol>
<ol><li> 这帮助确保和旧的实现的向后兼容性.
</li></ol>
<ol><li> 每个HTTP应答必须属于该请求触发的同一个会话, 但是不需要是同一个流.
</li></ol>
<ol><li> 广播的载荷可以使任何类型.
</li></ol>
<ol><li> SSL V3.0 &lt;<a rel="nofollow" class="external free" href="http://wp.netscape.com/eng/ssl3/draft302.txt">http://wp.netscape.com/eng/ssl3/draft302.txt</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2818">RFC 2818</a>: 在TLS上的HTTP &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc2818">http://tools.ietf.org/html/rfc2818</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc2817">RFC 2817</a>: 在HTTP/1.1中升级到TLS &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc2817">http://tools.ietf.org/html/rfc2817</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc1750">RFC 1750</a>: 基于安全的随机性建议 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc1750">http://tools.ietf.org/html/rfc1750</a>&gt;.
</li></ol>
<ol><li> <a class="external mw-magiclink-rfc" href="//tools.ietf.org/html/rfc4270">RFC 4270</a>: 在互联网协议里对加密哈希的攻击 &lt;<a rel="nofollow" class="external free" href="http://tools.ietf.org/html/rfc4270">http://tools.ietf.org/html/rfc4270</a>&gt;.
</li></ol>
<ol><li> 互联网编号分配机构 (IANA) 是对互联网协议的唯一参数值，类似端口号和URI规划，的分配的中央协调者. 更多信息, 见 &lt;<a rel="nofollow" class="external free" href="http://www.iana.org/">http://www.iana.org/</a>&gt;.
</li></ol>
<ol><li> 端口号的IANA注册 &lt;<a rel="nofollow" class="external free" href="http://www.iana.org/assignments/port-numbers">http://www.iana.org/assignments/port-numbers</a>&gt;.
</li></ol>
<ol><li> XEP-0156: 查找替代的XMPP连接方法 &lt;<a rel="nofollow" class="external free" href="http://xmpp.org/extensions/xep-0156.html">http://xmpp.org/extensions/xep-0156.html</a>&gt;.
</li></ol>
<h3> <span class="mw-headline" id=".E9.99.84.E5.BD.95H:.E4.BF.AE.E8.AE.A2.E5.8E.86.E5.8F.B2">附录H:修订历史</span></h3>
<p>注意: 本协议的旧版本可能在 <a rel="nofollow" class="external free" href="http://xmpp.org/extensions/attic/">http://xmpp.org/extensions/attic/</a> 还可用 
</p>
<dl><dt>Version 1.10 (2010-07-02)
</dt></dl>
<dl><dd>Further clarified use of 'from' and 'to' attributes; added missing condition values to the schema.
</dd><dd>(psa)
</dd><dt>Version 1.9 (2009-11-06)
</dt></dl>
<dl><dd>Added information for registration of port 5280 with IANA.
</dd><dd>(psa)
</dd><dt>Version 1.8 (2009-04-30)
</dt></dl>
<dl><dd>Removed secure attribute because it did not solve the problem it was intended to solve; added security consideration regarding link between connection manager and application server; changed "stanza" to "payload" for disambiguation with XMPP; clarified design objectives and relationship to similar technologies; corrected several errors in the schema.
</dd><dd>(psa/jm)
</dd><dt>Version 1.7 (2008-10-29)
</dt></dl>
<dl><dd>Moved alternative script syntax to historical specification; added implementation note about HTTP Pipelining; adjusted architectural description.
</dd><dd>(psa)
</dd><dt>Version 1.6 (2007-02-21)
</dt></dl>
<dl><dd>Multiple clarifications and restructuring without changes to protocol itself; changed title to BOSH; added section that fully explains the technique underlying the protocol; separated XMPP-specific features into new XEP-0206; added optional new Script Syntax and session pauses; added Acknowledgements section; added from and ver attributes; added hold attribute to session creation response; clarified polling too-frequently error; recommended that clients use HTTP Pipelining.
</dd><dd>(ip)
</dd><dt>Version 1.5 (2006-04-28)
</dt></dl>
<dl><dd>Added optional Multiple Streams section; added security considerations about encrypted HTTP connections; recommended use of SSL rather than HTTP over TLS; specified that request ID values must not exceed 9007199254740991; corrected datatypes of inactivity, polling, rid, and wait attributes in the schema; added &lt;any/&gt; and &lt;anyAttribute/&gt; elements to schema to optionally support non-XMPP XML elements and attributes; deprecated HTTP error codes in favor of new terminal binding conditions.
</dd><dd>(ip/psa)
</dd><dt>Version 1.4 (2005-12-14)
</dt></dl>
<dl><dd>Modified syntax of route attribute to be proto:host:port rather than XMPP URI/IRI.
</dd><dd>(psa)
</dd><dt>Version 1.3 (2005-11-02)
</dt></dl>
<dl><dd>Corrected stream:features namespace and the Recoverable Binding Conditions section; recommended that connection manager shall return secure attribute to client; recommended end-to-end encryption through proxy connection managers.
</dd><dd>(ip)
</dd><dt>Version 1.2 (2005-06-16)
</dt></dl>
<dl><dd>Specified optional use of route and secure attributes in session request. Minor correction: the stream features element should be included in the response that contains the authid attribute (this is not necessarily the session creation response).
</dd><dd>(ip)
</dd><dt>Version 1.1 (2005-06-02)
</dt></dl>
<dl><dd>Specified optional use of HTTP Accept-Encoding and Content-Encoding headers for compression at HTTP binding level.
</dd><dd>(ip)
</dd><dt>Version 1.0 (2005-03-03)
</dt></dl>
<dl><dd>Per a vote of the Jabber Council, advanced status to Draft.
</dd><dd>(psa)
</dd><dt>Version 0.10 (2004-11-08)
</dt></dl>
<dl><dd>Changed HTTP 401 errors to HTTP 404.
</dd><dd>(ip)
</dd><dt>Version 0.9 (2004-10-26)
</dt></dl>
<dl><dd>Added charset attribute.
</dd><dd>(ip/psa)
</dd><dt>Version 0.8 (2004-10-26)
</dt></dl>
<dl><dd>Specified that wait attribute must be included in the session creation response.
</dd><dd>(ip)
</dd><dt>Version 0.7 (2004-08-12)
</dt></dl>
<dl><dd>Defined appropriate XMPP stanza error conditions.
</dd><dd>(psa/ip)
</dd><dt>Version 0.6 (2004-07-19)
</dt></dl>
<dl><dd>Added xml:lang attribute to the session request; added recoverable binding error conditions.
</dd><dd>(ip)
</dd><dt>Version 0.5 (2004-05-07)
</dt></dl>
<dl><dd>Protocol refactored to enable simultaneous requests (request identifier attribute, wait attribute, hold attribute, requests attribute) and recovery of broken connections; added content attribute; removed all wrapper types except 'terminate'; updated error handling; made key mechanism optional (should use SSL/TLS instead).
</dd><dd>(ip/psa)
</dd><dt>Version 0.4 (2004-02-23)
</dt></dl>
<dl><dd>Fixed typos; removed "resource-constraint" binding error; added HTTP 403 error to table.
</dd><dd>(psa/ip)
</dd><dt>Version 0.3 (2004-02-19)
</dt></dl>
<dl><dd>Added 'authid' attribute to enable communication of XMPP stream ID (used in digest authentication); specified that Content-Types other than "text/xml" are allowed to support older HTTP clients; specified business rule for connection manager queueing of client requests; changed &lt;packet/&gt; to &lt;body/&gt; to support older HTTP clients; changed 'to' attribute on initialization element from MAY to SHOULD; recommended inclusion of unavailable presence in termination element sent from client; described architectural assumptions; specified binding-specific error handling.
</dd><dd>(psa/ip)
</dd><dt>Version 0.2 (2004-01-13)
</dt></dl>
<dl><dd>Added 'to' attribute on the initialization element; specified that 'text/html' is allowable for backwards-compatibility.
</dd><dd>(dss/psa/ip)
</dd><dt>Version 0.1 (2003-11-06)
</dt></dl>
<dl><dd>Initial version.
</dd><dd>(dss/psa)
</dd></dl>
<hr />
<p>结束
</p>
<!-- 
NewPP limit report
Preprocessor node count: 698/1000000
Post-expand include size: 0/2097152 bytes
Template argument size: 0/2097152 bytes
Expensive parser function count: 0/100
-->

<!-- Saved in parser cache with key mediawiki:pcache:idhash:65-0!*!0!!zh-cn!*!* and timestamp 20160221201748 -->
</div><div class="printfooter">
来自“<a href="http://wiki.jabbercn.org/index.php?title=XEP-0124&amp;oldid=3126">http://wiki.jabbercn.org/index.php?title=XEP-0124&amp;oldid=3126</a>”</div>
		<div id='catlinks' class='catlinks'><div id="mw-normal-catlinks"><a href="/%E7%89%B9%E6%AE%8A:%E9%A1%B5%E9%9D%A2%E5%88%86%E7%B1%BB" title="特殊:页面分类">2个分类</a>: <ul><li><a href="/%E5%88%86%E7%B1%BB:XMPP%E6%89%A9%E5%B1%95" title="分类:XMPP扩展">XMPP扩展</a></li><li><a href="/%E5%88%86%E7%B1%BB:%E5%B7%B2%E7%BF%BB%E8%AF%91" title="分类:已翻译">已翻译</a></li></ul></div></div>		<!-- end content -->
				<div class="visualClear"></div>
	</div>
</div></div>
<div id="column-one">
	<div id="p-cactions" class="portlet">
		<h5>查看</h5>
		<div class="pBody">
			<ul>
				<li id="ca-nstab-main" class="selected"><a href="/XEP-0124" title="查看内容页面 [c]" accesskey="c">页面</a></li>
				<li id="ca-talk" class="new"><a href="/index.php?title=%E8%AE%A8%E8%AE%BA:XEP-0124&amp;action=edit&amp;redlink=1" title="关于内容页面的讨论 [t]" accesskey="t">讨论</a></li>
				<li id="ca-viewsource"><a href="/index.php?title=XEP-0124&amp;action=edit" title="本页面已被保护。你可以查看其源代码。 [e]" accesskey="e">查看源代码</a></li>
				<li id="ca-history"><a href="/index.php?title=XEP-0124&amp;action=history" title="本页面的早前修订版本 [h]" accesskey="h">历史</a></li>
			</ul>
		</div>
	</div>

	<div class="portlet" id="p-personal">
		<h5>个人工具</h5>
		<div class="pBody">
			<ul>
				<li id="pt-login"><a href="/index.php?title=%E7%89%B9%E6%AE%8A:%E7%94%A8%E6%88%B7%E7%99%BB%E5%BD%95&amp;returnto=XEP-0124" title="我们希望您可以登入，但不强求 [o]" accesskey="o">登录/创建账户</a></li>
			</ul>
		</div>
	</div>
	<div class="portlet" id="p-logo">
		<a title="访问首页" style="background-image: url(/skins/common/images/xmppcn.png);" href="/%E9%A6%96%E9%A1%B5"></a>
	</div>
	<script type="text/javascript"> if (window.isMSIE55) fixalpha(); </script>
	<div class="generated-sidebar portlet" id="p-navigation">
		<h5>导航</h5>
		<div class='pBody'>
			<ul>
				<li id="n-mainpage-description"><a href="/%E9%A6%96%E9%A1%B5" title="访问首页 [z]" accesskey="z">首页</a></li>
				<li id="n-portal"><a href="/Jabber/XMPP%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92:%E7%A4%BE%E5%8C%BA%E4%B8%93%E9%A1%B5" title="关于本项目，你可以做什么，在哪里找到你需要的事物">社区专页</a></li>
				<li id="n-currentevents"><a href="/Jabber/XMPP%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92:%E6%96%B0%E9%97%BB%E5%8A%A8%E6%80%81" title="查看当前事件的背景信息">新闻动态</a></li>
				<li id="n-recentchanges"><a href="/%E7%89%B9%E6%AE%8A:%E6%9C%80%E8%BF%91%E6%9B%B4%E6%94%B9" title="本wiki的最近更改列表 [r]" accesskey="r">最近更改</a></li>
				<li id="n-randompage"><a href="/%E7%89%B9%E6%AE%8A:%E9%9A%8F%E6%9C%BA%E9%A1%B5%E9%9D%A2" title="随机进入一个页面 [x]" accesskey="x">随机页面</a></li>
				<li id="n-help"><a href="/%E5%B8%AE%E5%8A%A9:%E7%9B%AE%E5%BD%95" title="寻求帮助的地方">帮助</a></li>
			</ul>
		</div>
	</div>
	<div class="generated-sidebar portlet" id="p-XMPP.E8.B5.84.E6.BA.90">
		<h5>XMPP资源</h5>
		<div class='pBody'>
			<ul>
				<li id="n-XMPP.E5.85.AC.E5.85.B1.E6.9C.8D.E5.8A.A1"><a href="/XMPP%E5%85%AC%E5%85%B1%E6%9C%8D%E5%8A%A1">XMPP公共服务</a></li>
				<li id="n-XMPP.E5.AE.A2.E6.88.B7.E7.AB.AF.E8.BD.AF.E4.BB.B6"><a href="/XMPP%E5%AE%A2%E6%88%B7%E7%AB%AF%E8%BD%AF%E4%BB%B6">XMPP客户端软件</a></li>
				<li id="n-XMPP.E6.9C.8D.E5.8A.A1.E5.99.A8.E8.BD.AF.E4.BB.B6"><a href="/XMPP%E6%9C%8D%E5%8A%A1%E5%99%A8%E8%BD%AF%E4%BB%B6">XMPP服务器软件</a></li>
				<li id="n-.E5.8F.8B.E6.83.85.E9.93.BE.E6.8E.A5"><a href="/%E5%8F%8B%E6%83%85%E9%93%BE%E6%8E%A5">友情链接</a></li>
			</ul>
		</div>
	</div>
	<div id="p-search" class="portlet">
		<h5><label for="searchInput">搜索</label></h5>
		<div id="searchBody" class="pBody">
			<form action="/index.php" id="searchform">
				<input type='hidden' name="title" value="特殊:搜索"/>
				<input type="search" name="search" title="在Jabber/XMPP中文翻译计划中搜索 [f]" accesskey="f" id="searchInput" />
				<input type="submit" name="go" value="提交" title="如果相同的标题存在的话便直接前往该页面" id="searchGoButton" class="searchButton" />&#160;
				<input type="submit" name="fulltext" value="搜索" title="搜索含这些文字的页面" id="mw-searchButton" class="searchButton" />
			</form>
		</div>
	</div>




<script src="http://yacy.jabbercn.org:8090/yacy/ui/js/jquery-1.3.2.min.js" type="text/javascript"></script>
<script>
   $(document).ready(function() {
      yconf = {
         url : 'http://yacy.jabbercn.org:8090/',
         theme : 'smoothness',
         title : 'XMPP搜索大全',
         logo     : 'http://yacy.jabbercn.org:8090/env/grafics/50-xmpp_logo.jpg',
         link     : 'http://wiki.jabbercn.org',
         urlmaskfilter : '.*',
         width : 500,
         height : 500
      };
      $.getScript(yconf.url+'/yacy/ui/js/yacyui-portalsearch.js', function(){});
   });
</script>
        <div id="p-search" class="portlet">
<h5>站外搜索</h5>
<div id="yacylivesearch" class="pBody">
   <form id="ysearch" method="get" accept-charset="UTF-8" action="http://yacy.jabbercn.org:8090/yacysearch.html">
      <input name="search" id="yquery" type="text" size="8" maxlength="80" value=""/>
      <input type="hidden" name="verify" value="false" />
      <input type="hidden" name="maximumRecords" value="10" />
      <input type="hidden" name="resource" value="local" />
      <input type="hidden" name="urlmaskfilter" value=".*" />
      <input type="hidden" name="prefermaskfilter" value="" />
      <input type="hidden" name="former" value="" />
      <input type="hidden" name="display" value="2" />
      <input type="hidden" name="nav" value="all" />
      <input type="submit" name="Enter" value="搜索" class="searchButton" />
   </form>
</div>
</div>



	<div class="portlet" id="p-tb">
		<h5>工具箱</h5>
		<div class="pBody">
			<ul>
				<li id="t-whatlinkshere"><a href="/%E7%89%B9%E6%AE%8A:%E9%93%BE%E5%85%A5%E9%A1%B5%E9%9D%A2/XEP-0124" title="所有链入本页的wiki页面列表 [j]" accesskey="j">链入页面</a></li>
				<li id="t-recentchangeslinked"><a href="/%E7%89%B9%E6%AE%8A:%E9%93%BE%E5%87%BA%E6%9B%B4%E6%94%B9/XEP-0124" title="本页链入的页面的最近更改 [k]" accesskey="k">链出更改</a></li>
				<li id="t-specialpages"><a href="/%E7%89%B9%E6%AE%8A:%E7%89%B9%E6%AE%8A%E9%A1%B5%E9%9D%A2" title="所有特殊页面列表 [q]" accesskey="q">特殊页面</a></li>
				<li><a href="/index.php?title=XEP-0124&amp;printable=yes" rel="alternate">可打印版</a></li>
				<li id="t-permalink"><a href="/index.php?title=XEP-0124&amp;oldid=3126" title="本页面该修订版本的永久链接">永久链接</a></li>
			</ul>
		</div>
	</div>
</div><!-- end of the left (by default at least) column -->
<div class="visualClear"></div>
<div id="footer">
	<div id="f-copyrightico">
		<a href="http://creativecommons.org/licenses/by-nc-sa/3.0/"><img src="http://i.creativecommons.org/l/by-nc-sa/3.0/88x31.png" alt="Attribution-Noncommercial-Share Alike 3.0 Unported" width="88" height="31" /></a>
	</div>
	<div id="f-poweredbyico">
		<a href="http://www.mediawiki.org/"><img src="/skins/common/images/poweredby_mediawiki_88x31.png" alt="Powered by MediaWiki" width="88" height="31" /></a>
	</div>
	<ul id="f-list">
		<li id="lastmod"> 本页面最后修订于2013年7月8日 (星期一) 18:33。</li>
		<li id="viewcount">此页面已被浏览过63,587次。</li>
		<li id="copyright">本站全部文字内容使用<a class="external" href="http://creativecommons.org/licenses/by-nc-sa/3.0/">Attribution-Noncommercial-Share Alike 3.0 Unported</a>授权。</li>
		<li id="privacy"><a href="/Jabber/XMPP%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92:%E9%9A%90%E7%A7%81%E6%9D%83%E6%94%BF%E7%AD%96" title="Jabber/XMPP中文翻译计划:隐私权政策">隐私权政策</a></li>
		<li id="about"><a href="/Jabber/XMPP%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92:%E5%85%B3%E4%BA%8E" title="Jabber/XMPP中文翻译计划:关于">关于Jabber/XMPP中文翻译计划</a></li>
		<li id="disclaimer"><a href="/Jabber/XMPP%E4%B8%AD%E6%96%87%E7%BF%BB%E8%AF%91%E8%AE%A1%E5%88%92:%E5%85%8D%E8%B4%A3%E5%A3%B0%E6%98%8E" title="Jabber/XMPP中文翻译计划:免责声明">免责声明</a></li>
	</ul>
</div>
</div>
<script>if(window.mw){
	mw.loader.load(["mediawiki.user", "mediawiki.util", "mediawiki.page.ready", "mediawiki.legacy.wikibits", "mediawiki.legacy.ajax", "mediawiki.legacy.mwsuggest"]);
}
</script>
<script>if(window.mw){
	mw.user.options.set({"ccmeonemails":0,"cols":80,"date":"default","diffonly":0,"disablemail":0,"disablesuggest":0,"editfont":"default","editondblclick":0,"editsection":1,"editsectiononrightclick":0,"enotifminoredits":0,"enotifrevealaddr":0,"enotifusertalkpages":1,"enotifwatchlistpages":0,"extendwatchlist":0,"externaldiff":0,"externaleditor":0,"fancysig":0,"forceeditsummary":0,"gender":"unknown","hideminor":0,"hidepatrolled":0,"highlightbroken":1,"imagesize":2,"justify":0,"math":1,"minordefault":0,"newpageshidepatrolled":0,"nocache":0,"noconvertlink":0,"norollbackdiff":0,"numberheadings":0,"previewonfirst":0,"previewontop":1,"quickbar":5,"rcdays":7,"rclimit":50,"rememberpassword":0,"rows":25,"searchlimit":20,"showhiddencats":0,"showjumplinks":1,"shownumberswatching":1,"showtoc":1,"showtoolbar":1,"skin":"monobook","stubthreshold":0,"thumbsize":2,"underline":2,"uselivepreview":0,"usenewrc":0,"watchcreations":0,"watchdefault":0,"watchdeletion":0,"watchlistdays":3,"watchlisthideanons":0,
	"watchlisthidebots":0,"watchlisthideliu":0,"watchlisthideminor":0,"watchlisthideown":0,"watchlisthidepatrolled":0,"watchmoves":0,"wllimit":250,"variant":"zh-cn","language":"zh-cn","searchNs0":true,"searchNs1":false,"searchNs2":false,"searchNs3":false,"searchNs4":false,"searchNs5":false,"searchNs6":false,"searchNs7":false,"searchNs8":false,"searchNs9":false,"searchNs10":false,"searchNs11":false,"searchNs12":false,"searchNs13":false,"searchNs14":false,"searchNs15":false});;mw.user.tokens.set({"editToken":"+\\","watchToken":false});;mw.loader.state({"user.options":"ready","user.tokens":"ready"});
	
	/* cache key: mediawiki:resourceloader:filter:minify-js:4:42c4e9caefe8ca663d220ee0c286ac74 */
}
</script><!-- Piwik -->
<script type="text/javascript">
/* <![CDATA[ */
var pkBaseURL = (("https:" == document.location.protocol) ? "https://rtp.rooyee.im/piwik/" : "http://rtp.rooyee.im/piwik/");
document.write(unescape("%3Cscript src='" + pkBaseURL + "piwik.js' type='text/javascript'%3E%3C/script%3E"));
/* ]]> */
</script>
<script type="text/javascript">
/* <![CDATA[ */
try {
var piwikTracker = Piwik.getTracker(pkBaseURL + "piwik.php", 5);
piwikTracker.setDocumentTitle("XEP-0124");
piwikTracker.setIgnoreClasses("image");

piwikTracker.trackPageView();
piwikTracker.enableLinkTracking();
} catch( err ) {}
/* ]]> */
</script><noscript><p><img src="http://rtp.rooyee.im/piwik/piwik.php?idsite=5" style="border:0" alt=""/></p></noscript>
<!-- /Piwik --><!-- Served in 0.038 secs. --></body></html>